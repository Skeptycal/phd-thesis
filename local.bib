%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for cami at 2014-01-07 12:30:32 +0100 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{Lien08b,
	Abstract = {Back-in-time debuggers are extremely useful tools
                  for identifying the causes of bugs, as they allow us
                  to inspect the past states of objects no longer
                  present in the current execution stack.
                  Unfortunately the "omniscient" approaches that try
                  to remember all previous states are impractical
                  because they either consume too much space or they
                  are far too slow. Several approaches rely on
                  heuristics to limit these penalties, but they
                  ultimately end up throwing out too much relevant
                  information. In this paper we propose a practical
                  approach to back-in-time debugging that attempts to
                  keep track of only the relevant past data. In
                  contrast to other approaches, we keep object history
                  information together with the regular objects in the
                  application memory. Although seemingly
                  counter-intuitive, this approach has the effect that
                  past data that is not reachable from current
                  application objects (and hence, no longer relevant)
                  is automatically garbage collected. In this paper we
                  describe the technical details of our approach, and
                  we present benchmarks that demonstrate that memory
                  consumption stays within practical bounds.
                  Furthermore since our approach works at the virtual
                  machine level, the performance penalty is
                  significantly better than with other approaches.},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 22nd European Conference on Object-Oriented Programming (ECOOP'08)},
	Date-Added = {2014-01-07 10:43:48 +0000},
	Date-Modified = {2014-01-07 10:43:48 +0000},
	Doi = {10.1007/978-3-540-70592-5_25},
	Isbn = {978-3-540-70591-8},
	Keywords = {scg08 scg-pub object-flow snf08 jb08 girba},
	Medium = {2},
	Note = {{ECOOP} distinguished paper award},
	Pages = {592--615},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Practical Object-Oriented Back-in-Time Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Volume = {5142},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSC4uLy4uL3BhcGVyL0xpZW4wOGIgUHJhY3RpY2FsIE9iamVjdC1PcmllbnRlZCBCYWNrLWluLVRpbWUgRGVidWdnaW5nLnBkZtIXCxgZV05TLmRhdGFPEQISAAAAAAISAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfTGllbjA4YiBQcmFjdGljYWwgT2JqI0U0MDZBLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5Aasooq5IAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMooj3IAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBMaWVuMDhiIFByYWN0aWNhbCBPYmojRTQwNkEucGRmAAAOAHoAPABMAGkAZQBuADAAOABiACAAUAByAGEAYwB0AGkAYwBhAGwAIABPAGIAagBlAGMAdAAtAE8AcgBpAGUAbgB0AGUAZAAgAEIAYQBjAGsALQBpAG4ALQBUAGkAbQBlACAARABlAGIAdQBnAGcAaQBuAGcALgBwAGQAZgAPAAgAAwBPAFMAWAASAFxVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0xpZW4wOGIgUHJhY3RpY2FsIE9iamVjdC1PcmllbnRlZCBCYWNrLWluLVRpbWUgRGVidWdnaW5nLnBkZgATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOANkA3gDmAvwC/gMDAw4DFwMlAykDMAM5Az4DSwNOA2ADYwNoAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA2o=},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-70592-5_25}}

@article{Arna13a,
	Abstract = {{Controlling object graphs and giving specific semantics to references (such as read-only, own- ership, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to be able to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is the underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementation of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.}},
	Affiliation = {RMOD - INRIA Lille - Nord Europe},
	Audience = {internationale},
	Author = {Arnaud, Jean-Baptiste and Ducasse, St{\'e}phane and Denker, Marcus},
	Date-Added = {2014-01-07 10:41:30 +0000},
	Date-Modified = {2014-01-07 10:41:30 +0000},
	Hal_Id = {hal-00881865},
	Journal = {Science of Computer Programming},
	Language = {Anglais},
	Month = Nov,
	Pdf = {http://hal.inria.fr/hal-00881865/PDF/Arna13b-Handles-ScienceOfComputerProgramming.pdf},
	Publisher = {Elsevier},
	Title = {{Handles: Behavior-Propagating First Class References For Dynamically-Typed Languages}},
	Url = {http://hal.inria.fr/hal-00881865},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qay4uLy4uL3BhcGVyL0FybmExM2EgSGFuZGxlcyBCZWhhdmlvci1Qcm9wYWdhdGluZyBGaXJzdCBDbGFzcyBSZWZlcmVuY2VzIEZvciBEeW5hbWljYWxseS1UeXBlZCBMYW5ndWFnZXMucGRm0hcLGBlXTlMuZGF0YU8RAnwAAAAAAnwAAgAAA09TWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMroJ/NIKwAAAA4/DB9Bcm5hMTNhIEhhbmRsZXMgQmVoIzZCQzQzOUUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGvEOezvGYVQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAyugZ4wAAABEACAAAzvGKRQAAAAEAEAAOPwwACxyKAAZRzQAC5owAAgBHT1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGFwZXI6AEFybmExM2EgSGFuZGxlcyBCZWgjNkJDNDM5RS5wZGYAAA4AwABfAEEAcgBuAGEAMQAzAGEAIABIAGEAbgBkAGwAZQBzACAAQgBlAGgAYQB2AGkAbwByAC0AUAByAG8AcABhAGcAYQB0AGkAbgBnACAARgBpAHIAcwB0ACAAQwBsAGEAcwBzACAAUgBlAGYAZQByAGUAbgBjAGUAcwAgAEYAbwByACAARAB5AG4AYQBtAGkAYwBhAGwAbAB5AC0AVAB5AHAAZQBkACAATABhAG4AZwB1AGEAZwBlAHMALgBwAGQAZgAPAAgAAwBPAFMAWAASAH9Vc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0FybmExM2EgSGFuZGxlcyBCZWhhdmlvci1Qcm9wYWdhdGluZyBGaXJzdCBDbGFzcyBSZWZlcmVuY2VzIEZvciBEeW5hbWljYWxseS1UeXBlZCBMYW5ndWFnZXMucGRmAAATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAPwBAQEJA4kDiwOQA5sDpAOyA7YDvQPGA8sD2APbA+0D8AP1AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA/c=},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00881865}}

@inproceedings{Deut84a,
	Address = {Salt Lake City, Utah},
	Author = {L. Peter Deutsch and Allan M. Schiffman},
	Booktitle = {Proceedings POPL '84},
	Date-Added = {2013-12-17 21:35:44 +0000},
	Date-Modified = {2013-12-17 21:35:44 +0000},
	Doi = {10.1145/800017.800542},
	Keywords = {olit-oopl smalltalk casais popl84},
	Misc = {Jan. 15-18},
	Month = jan,
	Title = {Efficient Implementation of the {Smalltalk-80} system},
	Url = {http://webpages.charter.net/allanms/popl84.pdf},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSy4uLy4uL3BhcGVyL0RldXQ4NGEgRWZmaWNpZW50IEltcGxlbWVudGF0aW9uIG9mIHRoZSBTbWFsbHRhbGstODAgc3lzdGVtLnBkZtIXCxgZV05TLmRhdGFPEQIcAAAAAAIcAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfRGV1dDg0YSBFZmZpY2llbnQgSW1wI0U0MDEwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5AEMisDUoAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMir8SoAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBEZXV0ODRhIEVmZmljaWVudCBJbXAjRTQwMTAucGRmAAAOAIAAPwBEAGUAdQB0ADgANABhACAARQBmAGYAaQBjAGkAZQBuAHQAIABJAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AIABvAGYAIAB0AGgAZQAgAFMAbQBhAGwAbAB0AGEAbABrAC0AOAAwACAAcwB5AHMAdABlAG0ALgBwAGQAZgAPAAgAAwBPAFMAWAASAF9Vc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0RldXQ4NGEgRWZmaWNpZW50IEltcGxlbWVudGF0aW9uIG9mIHRoZSBTbWFsbHRhbGstODAgc3lzdGVtLnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDcAOEA6QMJAwsDEAMbAyQDMgM2Az0DRgNLA1gDWwNtA3ADdQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAN3},
	Bdsk-Url-1 = {http://webpages.charter.net/allanms/popl84.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/800017.800542}}

@inproceedings{Verw10a,
	Abstract = {To support development tools like debuggers, runtime systems need to provide a meta-programming interface to alter their semantics and access internal data. Reflective capabilities are typically fixed by the Virtual Machine ({VM}). Unanticipated reflective features must either be simulated by complex program transformations, or they require the development of a specially tailored {VM}. We propose a novel approach to behavioral reflection that eliminates the barrier between applications and the {VM} by manipulating an explicit tower of first-class interpreters. Pinocchio is a proof-of-concept implementation of our approach which enables radical changes to the interpretation of programs by explicitly instantiating subclasses of the base interpreter. We illustrate the design of Pinocchio through non-trivial examples that extend runtime semantics to support debugging, parallel debugging, and back-in-time object-flow debugging. Although performance is not yet addressed, we also discuss numerous opportunities for optimization, which we believe will lead to a practical approach to behavioral reflection.},
	Address = {New York, NY, USA},
	Author = {Verwaest, Toon and Bruni, Camillo and Gurtner, David and Lienhard, Adrian and Niestrasz, Oscar},
	Booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
	Citeulike-Article-Id = {12819592},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1869522},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1869459.1869522},
	Date-Added = {2013-12-04 17:33:21 +0000},
	Date-Modified = {2013-12-04 17:33:21 +0000},
	Doi = {10.1145/1869459.1869522},
	Isbn = {978-1-4503-0203-6},
	Location = {Reno/Tahoe, Nevada, USA},
	Pages = {774--789},
	Posted-At = {2013-12-04 17:32:31},
	Priority = {2},
	Publisher = {ACM},
	Series = {OOPSLA '10},
	Title = {Pinocchio: Bringing Reflection to Life with First-class Interpreters},
	Url = {http://dx.doi.org/10.1145/1869459.1869522},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXC4uLy4uL3BhcGVyL1ZlcncxMGFiIFBpbm9jY2hpbyBCcmluZ2luZyBSZWZsZWN0aW9uIHRvIExpZmUgd2l0aCBGaXJzdC1jbGFzcyBJbnRlcnByZXRlcnMucGRm0hcLGBlXTlMuZGF0YU8RAk4AAAAAAk4AAgAAA09TWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMroJ/NIKwAAAA4/DB9WZXJ3MTBhYiBQaW5vY2NoaW8gQnIjRTQxNDUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADkFFycTdrwAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAyugZ4wAAABEACAAAycTBjwAAAAEAEAAOPwwACxyKAAZRzQAC5owAAgBHT1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGFwZXI6AFZlcncxMGFiIFBpbm9jY2hpbyBCciNFNDE0NS5wZGYAAA4AogBQAFYAZQByAHcAMQAwAGEAYgAgAFAAaQBuAG8AYwBjAGgAaQBvACAAQgByAGkAbgBnAGkAbgBnACAAUgBlAGYAbABlAGMAdABpAG8AbgAgAHQAbwAgAEwAaQBmAGUAIAB3AGkAdABoACAARgBpAHIAcwB0AC0AYwBsAGEAcwBzACAASQBuAHQAZQByAHAAcgBlAHQAZQByAHMALgBwAGQAZgAPAAgAAwBPAFMAWAASAHBVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL1ZlcncxMGFiIFBpbm9jY2hpbyBCcmluZ2luZyBSZWZsZWN0aW9uIHRvIExpZmUgd2l0aCBGaXJzdC1jbGFzcyBJbnRlcnByZXRlcnMucGRmABMAAS8AABUAAgAL//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A7QDyAPoDTANOA1MDXgNnA3UDeQOAA4kDjgObA54DsAOzA7gAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADug==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1869459.1869522}}

@inproceedings{Fish00a,
	Abstract = {Practical implementations of high-level languages must provide access to libraries and system  services that have {APIs} specified in a low-level language (usually C). Our approach to  supporting foreign interfaces in the {MOBY} compiler is based on a mechanism for data-level  interoperability, which allows {MOBY} code to manipulate C data representations directly. Datalevel  interoperability is important when dealing with large external data sets or data that is in  a fixed format. It also serves as the foundation for a wide range of different foreign-interface  policies. We describe tools that implement three such policies: Charon, which embeds C types  directly into {MOBY}, moby-idl, which provides an {IDL}-based embedding, and an {API} miner,  which enables application-specific embeddings. The benefits of our approach stem from the  design of our compiler and do not rely on properties of the {MOBY} language.  1 Introduction  High-level languages, such as most functional and object-oriented langu...},
	Author = {Fisher, Kathleen and Pucella, Riccardo and Reppy, John},
	Booktitle = {Electronic Notes in Theoretical Computer Science},
	Citeulike-Article-Id = {12819568},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965},
	Date-Added = {2013-12-04 17:12:09 +0000},
	Date-Modified = {2013-12-04 17:12:09 +0000},
	Doi = {10.1.1.43.4965},
	Posted-At = {2013-12-04 17:11:42},
	Priority = {2},
	Title = {{Data-Level} Interoperability},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMy4uLy4uL3BhcGVyL0Zpc2gwMGEgRGF0YS1MZXZlbCBJbnRlcm9wZXJhYmlsaXR5LnBkZtIXCxgZV05TLmRhdGFPEQHUAAAAAAHUAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfRmlzaDAwYSBEYXRhLUxldmVsICM2OEMzM0ZCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABowz+87FINEAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAM7FEsEAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBGaXNoMDBhIERhdGEtTGV2ZWwgIzY4QzMzRkIucGRmAAAOAFAAJwBGAGkAcwBoADAAMABhACAARABhAHQAYQAtAEwAZQB2AGUAbAAgAEkAbgB0AGUAcgBvAHAAZQByAGEAYgBpAGwAaQB0AHkALgBwAGQAZgAPAAgAAwBPAFMAWAASAEdVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0Zpc2gwMGEgRGF0YS1MZXZlbCBJbnRlcm9wZXJhYmlsaXR5LnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDEAMkA0QKpAqsCsAK7AsQC0gLWAt0C5gLrAvgC+wMNAxADFQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMX},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965}}

@inproceedings{Repp06b,
	Acmid = {1173714},
	Address = {New York, NY, USA},
	Author = {Reppy, John and Song, Chunyan},
	Booktitle = {Proceedings of the 5th international conference on Generative programming and component engineering},
	Date-Added = {2013-12-04 17:08:38 +0000},
	Date-Modified = {2013-12-04 17:08:38 +0000},
	Doi = {10.1145/1173706.1173714},
	Isbn = {1-59593-237-2},
	Keywords = {foreign-interface generation, term rewriting},
	Location = {Portland, Oregon, USA},
	Numpages = {10},
	Pages = {49--58},
	Publisher = {ACM},
	Series = {GPCE '06},
	Title = {Application-specific foreign-interface generation},
	Url = {http://doi.acm.org/10.1145/1173706.1173714},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSS4uLy4uL3BhcGVyL1JlcHAwNmIgQXBwbGljYXRpb24tc3BlY2lmaWMgZm9yZWlnbi1pbnRlcmZhY2UgZ2VuZXJhdGlvbi5wZGbSFwsYGVdOUy5kYXRhTxECFgAAAAACFgACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH1JlcHAwNmIgQXBwbGljYXRpb24jNjhDMzA1OC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaMMFjOxSATAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADOxRIDAAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoAUmVwcDA2YiBBcHBsaWNhdGlvbiM2OEMzMDU4LnBkZgAADgB8AD0AUgBlAHAAcAAwADYAYgAgAEEAcABwAGwAaQBjAGEAdABpAG8AbgAtAHMAcABlAGMAaQBmAGkAYwAgAGYAbwByAGUAaQBnAG4ALQBpAG4AdABlAHIAZgBhAGMAZQAgAGcAZQBuAGUAcgBhAHQAaQBvAG4ALgBwAGQAZgAPAAgAAwBPAFMAWAASAF1Vc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL1JlcHAwNmIgQXBwbGljYXRpb24tc3BlY2lmaWMgZm9yZWlnbi1pbnRlcmZhY2UgZ2VuZXJhdGlvbi5wZGYAABMAAS8AABUAAgAL//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A2gDfAOcDAQMDAwgDEwMcAyoDLgM1Az4DQwNQA1MDZQNoA20AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADbw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1173706.1173714}}

@inproceedings{Blac04a,
	Acmid = {999420},
	Address = {Washington, DC, USA},
	Author = {Blackburn, Stephen M. and Cheng, Perry and McKinley, Kathryn S.},
	Booktitle = {Proceedings of the 26th International Conference on Software Engineering},
	Date-Added = {2013-12-04 17:07:19 +0000},
	Date-Modified = {2013-12-04 17:07:19 +0000},
	Doi = {10.1.1.123.2069},
	Isbn = {0-7695-2163-0},
	Numpages = {10},
	Pages = {137--146},
	Publisher = {IEEE Computer Society},
	Series = {ICSE '04},
	Title = {Oil and Water? {High} Performance Garbage Collection in {Java} with {MMTk}},
	Url = {http://dl.acm.org/citation.cfm?id=998675.999420},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXC4uLy4uL3BhcGVyL0JsYWMwNGEgT2lsIGFuZCBXYXRlcj8gSGlnaCBQZXJmb3JtYW5jZSBHYXJiYWdlIENvbGxlY3Rpb24gaW4gSmF2YSB3aXRoIE1NVGsucGRm0hcLGBlXTlMuZGF0YU8RAk4AAAAAAk4AAgAAA09TWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMroJ/NIKwAAAA4/DB9CbGFjMDRhIE9pbCBhbmQgV2F0IzY4QzJFMkUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGjC4uzsUfjgAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAyugZ4wAAABEACAAAzsURfgAAAAEAEAAOPwwACxyKAAZRzQAC5owAAgBHT1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGFwZXI6AEJsYWMwNGEgT2lsIGFuZCBXYXQjNjhDMkUyRS5wZGYAAA4AogBQAEIAbABhAGMAMAA0AGEAIABPAGkAbAAgAGEAbgBkACAAVwBhAHQAZQByAD8AIABIAGkAZwBoACAAUABlAHIAZgBvAHIAbQBhAG4AYwBlACAARwBhAHIAYgBhAGcAZQAgAEMAbwBsAGwAZQBjAHQAaQBvAG4AIABpAG4AIABKAGEAdgBhACAAdwBpAHQAaAAgAE0ATQBUAGsALgBwAGQAZgAPAAgAAwBPAFMAWAASAHBVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0JsYWMwNGEgT2lsIGFuZCBXYXRlcj8gSGlnaCBQZXJmb3JtYW5jZSBHYXJiYWdlIENvbGxlY3Rpb24gaW4gSmF2YSB3aXRoIE1NVGsucGRmABMAAS8AABUAAgAL//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A7QDyAPoDTANOA1MDXgNnA3UDeQOAA4kDjgObA54DsAOzA7gAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADug==},
	Bdsk-Url-1 = {http://dl.acm.org/citation.cfm?id=998675.999420}}

@inproceedings{Ande98a,
	Abstract = {This is a note on reflection in Python 1.5. Both this and earlier versions of Python has an open implementation where we can access and alter the internal structures of language components. Python 1.5 takes this one step further making it even easier to adapt a reflective programming model. These dynamic features of Python were one of the reasons for chosing it as the language used to implement an experimental reflective middleware platform in the {SUMO} {II} project. We will in this note describe the open implementation in Python 1.5 and show how it can be used to achieve a reflective programming model. The note also includes a description of our reflection module for Python. 1 Introduction  Python 1.4, which was the previous release of Python, was recognized as a good choice for a language implementing a experimental reflective middleware platform in the {SUMO} {II} project [1]. All the dynamic features in the language made it possible to go behind the scene and inspect and change the behavi...},
	Author = {Andersen, Anders},
	Booktitle = {Lancaster University},
	Citeulike-Article-Id = {12212143},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504},
	Date-Added = {2013-12-04 16:55:50 +0000},
	Date-Modified = {2013-12-04 16:55:50 +0000},
	Doi = {10.1.1.50.9504},
	Posted-At = {2013-03-26 13:34:38},
	Priority = {2},
	Title = {A note on reflection in Python 1.5},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504},
	Year = {1998},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504}}

@mastersthesis{Brun11a,
	Abstract = {Optimizations are an omnipresent topic when working on Virtual Machines (VMs). There is a
		plethora of different optimizations available ranging from simple tweaks and tricks to full
        evaluation concepts requiring a complex infrastructure. Depending on the complexity of an
        optimization and the performance increase it is important to choose the right kinds of optimizations.
        Based on a high-level language VM as a case study we argue in favor of transparent optimizations
        which do not require changes in the interpreted language's semantics. Furthermore it is necessary to
        write and properly evaluate benchmarks to be able to track the performance impact of a certain
        optimization. When building a high-level language VM the underlying system -- traditionally a C or
        C++ core -- does not share many concepts with the implemented language. Hence some optimizations
        emerging from the low-level VM core are orthogonal to the high-level concepts of the interpreted
        language. Focusing on such optimizations can strongly limit the dynamic capabilities of a high-level
        language. These non-transparent optimizations require the semantics of the interpreted language to be
        changed. Changes in the language's semantics can require extensive changes in the sources which is an
        undesired property. However transparent optimizations preserve semantics of the language. Using
        transparent optimizations helps to separate the low-level requirements of the VM form the high-level
        design decisions of the language. We argue that non-transparent optimizations should only be applied
        to a high-level language VM in an early development stage. Furthermore each non-transparent
        optimization should be paired with a compatible way to reintroduce the lost or altered semantics. To
        make valid statements about optimizations it is necessary to write adequate benchmarks. The
        benchmarks have to be reproducible and the evaluation has to be statistically sound, furthermore the
        benchmarks should focus on covering specific use cases to help locating performance issues in the VM
        code. Benchmarks are to be used in a similar way as unit tests. Optimizations can only be evaluated
        in a sound way when the corresponding benchmarks produce deterministic values. Furthermore we state
        that focusing on micro benchmarks helps to locate and track performance critical code segments of the
        VM.},
	Added-At = {2011-02-05T16:38:54.000+0100},
	Author = {Bruni, Camillo},
	Biburl = {http://www.bibsonomy.org/bibtex/288adb7c61909729df1b12184fb13cb66/gron},
	Date-Added = {2013-12-04 16:53:48 +0000},
	Date-Modified = {2013-12-04 16:53:48 +0000},
	Interhash = {9c6b78e09362e9033baf90c80ce6a845},
	Intrahash = {88adb7c61909729df1b12184fb13cb66},
	Keywords = {Debugger Optimization Parallel Pinocchio VM},
	Month = jan,
	School = {University of Bern},
	Timestamp = {2011-02-05T16:38:54.000+0100},
	Title = {{Optimizing Pinocchio}},
	Type = {Master's Thesis},
	Url = {http://scg.unibe.ch/archive/masters/Brun11a.pdf},
	Year = 2011,
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/masters/Brun11a.pdf}}

@article{Verw11a,
	Abstract = {Programming idioms, design patterns and application libraries often introduce cumbersome and repetitive boilerplate code to a software system. Language extensions and external {DSLs} (domain specific languages) are sometimes introduced to reduce the need for boilerplate code, but they also complicate the system by introducing the need for language dialects and inter-language mediation. To address this, we propose to extend the structural reflective model of the language with object layouts, layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to object layouts that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language extensions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported. We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples.},
	Address = {New York, NY, USA},
	Author = {Verwaest, Toon and Bruni, Camillo and Lungu, Mircea and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications},
	Citeulike-Article-Id = {10181088},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2048066.2048138},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2048066.2048138},
	Date-Added = {2013-12-04 16:53:39 +0000},
	Date-Modified = {2013-12-04 16:53:39 +0000},
	Doi = {10.1145/2048066.2048138},
	Isbn = {978-1-4503-0940-0},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Location = {Portland, Oregon, USA},
	Month = oct,
	Number = {10},
	Pages = {959--972},
	Posted-At = {2013-11-11 15:13:01},
	Priority = {2},
	Publisher = {ACM},
	Series = {OOPSLA '11},
	Title = {Flexible object layouts: enabling lightweight language extensions by intercepting slot access},
	Url = {http://dx.doi.org/10.1145/2048066.2048138},
	Volume = {46},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2048066.2048138}}

@inproceedings{Chis12a,
	Abstract = {Smalltalk, in spite of myriad advantages in terms of ease of development, has been largely eclipsed by lower-level languages like C, which has become the lingua franca on modern systems. This paper introduces the Pragmatic Smalltalk compiler, which provides a dialect of Smalltalk that is designed from the ground up for close interoperability with C libraries. We describe how high-level Smalltalk language features are lowered to allow execution without a virtual machine, allowing Smalltalk and C code to be mixed in the same program without hard boundaries between the two. This allows incremental deployment of Smalltalk code in programs and libraries along with heavily optimised low-level C and assembly routines for performance critical segments.},
	Address = {New York, NY, USA},
	Author = {Chisnall, David},
	Booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
	Citeulike-Article-Id = {12438519},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2448963.2448967},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2448963.2448967},
	Date-Added = {2013-12-04 16:53:33 +0000},
	Date-Modified = {2013-12-04 16:53:33 +0000},
	Doi = {10.1145/2448963.2448967},
	Isbn = {978-1-4503-1897-6},
	Location = {Ghent, Belgium},
	Posted-At = {2013-06-19 15:27:49},
	Priority = {2},
	Publisher = {ACM},
	Series = {IWST '12},
	Title = {{Smalltalk} in a {C} world},
	Url = {http://dx.doi.org/10.1145/2448963.2448967},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLi4uLy4uL3BhcGVyL0NoaXMxMmEgU21hbGx0YWxrIGluIGEgQyB3b3JsZC5wZGbSFwsYGVdOUy5kYXRhTxEBxAAAAAABxAACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH0NoaXMxMmEgU21hbGx0YWxrIGkjNTREN0EyNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVNeiTN54yFUERGIAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADN53BlAAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoAQ2hpczEyYSBTbWFsbHRhbGsgaSM1NEQ3QTI0LnBkZgAADgBGACIAQwBoAGkAcwAxADIAYQAgAFMAbQBhAGwAbAB0AGEAbABrACAAaQBuACAAYQAgAEMAIAB3AG8AcgBsAGQALgBwAGQAZgAPAAgAAwBPAFMAWAASAEJVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0NoaXMxMmEgU21hbGx0YWxrIGluIGEgQyB3b3JsZC5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC/AMQAzAKUApYCmwKmAq8CvQLBAsgC0QLWAuMC5gL4AvsDAAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMC},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2448963.2448967}}

@article{Ball86a,
	Abstract = {{QUICKTALK} is a dialect of Smalltalk-80 that can be compiled directly into native machine code, instead of virtual machine bytecodes. The dialect includes  '' hints'' on the class of method arguments, instance variables, and class variables. We designed the dialect to describe primitive Smalltalk methods. {QUICKTALK} achieves improved performance over bytecodes by eliminating the interpreter loop on bytecode execution, by reducing the number of message send/returns via binding some target methods at compilation, and by eliminating redundant class checking. We identify changes to the Smalltalk-80 system and compiler to support the dialect, and give performance measurements.},
	Address = {New York, NY, USA},
	Author = {Ballard, Mark B. and Maier, David and Brock, Allen W.},
	Citeulike-Article-Id = {10744787},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=28697.28711},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/960112.28711},
	Date-Added = {2013-12-04 16:53:29 +0000},
	Date-Modified = {2013-12-04 16:53:29 +0000},
	Doi = {10.1145/960112.28711},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = jun,
	Number = {11},
	Pages = {140--150},
	Posted-At = {2012-06-05 12:41:15},
	Priority = {2},
	Publisher = {ACM},
	Rating = {3},
	Read = {1},
	Title = {{QUICKTALK}: a {Smalltalk-80} dialect for defining primitive methods},
	Url = {http://dx.doi.org/10.1145/960112.28711},
	Volume = {21},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QVy4uLy4uL3BhcGVyL0JhbGw4NmEgUVVJQ0tUQUxLIGEgU21hbGx0YWxrLTgwIGRpYWxlY3QgZm9yIGRlZmluaW5nIHByaW1pdGl2ZSBtZXRob2RzLnBkZtIXCxgZV05TLmRhdGFPEQJAAAAAAAJAAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfQmFsbDg2YSBRVUlDS1RBTEsgYSMxOTJGRTY4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZL+aMvuynoAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMvurloAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBCYWxsODZhIFFVSUNLVEFMSyBhIzE5MkZFNjgucGRmAAAOAJgASwBCAGEAbABsADgANgBhACAAUQBVAEkAQwBLAFQAQQBMAEsAIABhACAAUwBtAGEAbABsAHQAYQBsAGsALQA4ADAAIABkAGkAYQBsAGUAYwB0ACAAZgBvAHIAIABkAGUAZgBpAG4AaQBuAGcAIABwAHIAaQBtAGkAdABpAHYAZQAgAG0AZQB0AGgAbwBkAHMALgBwAGQAZgAPAAgAAwBPAFMAWAASAGtVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0JhbGw4NmEgUVVJQ0tUQUxLIGEgU21hbGx0YWxrLTgwIGRpYWxlY3QgZm9yIGRlZmluaW5nIHByaW1pdGl2ZSBtZXRob2RzLnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDoAO0A9QM5AzsDQANLA1QDYgNmA20DdgN7A4gDiwOdA6ADpQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOn},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/960112.28711}}

@inproceedings{Kell11a,
	Annote = {internationalworkshop},
	Author = {Stephen Kell and Conrad Irwin},
	Booktitle = {VMIL '11: Proceedings of the 5th workshop on Virtual machines and intermediate languages for emerging modularization mechanisms},
	Date-Added = {2013-12-04 16:53:26 +0000},
	Date-Modified = {2013-12-04 16:53:26 +0000},
	Location = {Portland, Oregon, U.S.A.},
	Pages = {6},
	Publisher = {ACM},
	Rating = {4},
	Read = {1},
	Title = {Virtual machines should be invisible},
	Url = {http://www.cs.iastate.edu/~design/vmil/2011/papers/p02-kell.pdf},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QPC4uLy4uL3BhcGVyL0tlbGwxMWEgVmlydHVhbCBtYWNoaW5lcyBzaG91bGQgYmUgaW52aXNpYmxlLnBkZtIXCxgZV05TLmRhdGFPEQHuAAAAAAHuAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfS2VsbDExYSBWaXJ0dWFsIG1hY2gjNjUxRDQ0LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGUdRMsOZjAAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMsOWCAAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBLZWxsMTFhIFZpcnR1YWwgbWFjaCM2NTFENDQucGRmAAAOAGIAMABLAGUAbABsADEAMQBhACAAVgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAcwAgAHMAaABvAHUAbABkACAAYgBlACAAaQBuAHYAaQBzAGkAYgBsAGUALgBwAGQAZgAPAAgAAwBPAFMAWAASAFBVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0tlbGwxMWEgVmlydHVhbCBtYWNoaW5lcyBzaG91bGQgYmUgaW52aXNpYmxlLnBkZgATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAM0A0gDaAswCzgLTAt4C5wL1AvkDAAMJAw4DGwMeAzADMwM4AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAzo=},
	Bdsk-Url-1 = {http://www.cs.iastate.edu/~design/vmil/2011/papers/p02-kell.pdf}}

@article{Bolz08a,
	Abstract = {We report on our experiences with the  Spy  project, including implementation details and benchmark results.  Spy  is a re-implementation of the Squeak ( i.e.  Smalltalk-80) VM using the PyPy toolchain. The PyPy project allows code written in RPython, a subset of Python, to be translated to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters can be derived from one abstract interpreter definition.  Spy  aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current  Spy  codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk VMs, but which still run slower than in Squeak itself.  Spy  was built from scratch over the course of a week during a joint Squeak-PyPy Sprint in Bern last autumn.},
	Address = {Berlin, Heidelberg},
	Author = {Bolz, Carl F. and Kuhn, Adrian and Lienhard, Adrian and Matsakis, Nicholas D. and Nierstrasz, Oscar and Renggli, Lukas and Rigo, Armin and Verwaest, Toon},
	Citeulike-Article-Id = {5033558},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1482373.1482382},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	Citeulike-Linkout-2 = {http://www.springerlink.com/content/n5v3uu17u4t51432},
	Date-Added = {2013-12-04 16:53:14 +0000},
	Date-Modified = {2013-12-04 16:53:14 +0000},
	Doi = {10.1007/978-3-540-89275-5_7},
	Isbn = {978-3-540-89274-8},
	Journal = {Self-Sustaining Systems},
	Keywords = {pypy, sprint},
	Pages = {123--139},
	Posted-At = {2010-08-16 14:33:20},
	Priority = {2},
	Publisher = {Springer-Verlag},
	Read = {1},
	Title = {Back to the Future in One Week -- Implementing a {Smalltalk} VM in {PyPy}},
	Url = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXS4uLy4uL3BhcGVyL0JvbHowOGEgQmFjayB0byB0aGUgRnV0dXJlIGluIE9uZSBXZWVrIC0tIEltcGxlbWVudGluZyBhIFNtYWxsdGFsayBWTSBpbiBQeVB5LnBkZtIXCxgZV05TLmRhdGFPEQJSAAAAAAJSAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfQm9sejA4YSBCYWNrIHRvIHRoZSBGI0UzRkUzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4/48iPCuQAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMiO7sQAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBCb2x6MDhhIEJhY2sgdG8gdGhlIEYjRTNGRTMucGRmAAAOAKQAUQBCAG8AbAB6ADAAOABhACAAQgBhAGMAawAgAHQAbwAgAHQAaABlACAARgB1AHQAdQByAGUAIABpAG4AIABPAG4AZQAgAFcAZQBlAGsAIAAtAC0AIABJAG0AcABsAGUAbQBlAG4AdABpAG4AZwAgAGEAIABTAG0AYQBsAGwAdABhAGwAawAgAFYATQAgAGkAbgAgAFAAeQBQAHkALgBwAGQAZgAPAAgAAwBPAFMAWAASAHFVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0JvbHowOGEgQmFjayB0byB0aGUgRnV0dXJlIGluIE9uZSBXZWVrIC0tIEltcGxlbWVudGluZyBhIFNtYWxsdGFsayBWTSBpbiBQeVB5LnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDuAPMA+wNRA1MDWANjA2wDegN+A4UDjgOTA6ADowO1A7gDvQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAO/},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-540-89275-5_7}}

@inproceedings{Unga07a,
	Abstract = {The years 1985 through 1995 saw the birth and development of the language Self, starting from its design by the authors at Xerox {PARC}, through first implementations by Ungar and his graduate students at Stanford University, and then with a larger team formed when the authors joined Sun Microsystems Laboratories in 1991. Self was designed to help programmers become more productive and creative by giving them a simple, pure, and powerful language, an implementation that combined ease of use with high performance, a user interface that off-loaded cognitive burden, and a programming environment that captured the malleability of a physical world of live objects. Accomplishing these goals required innovation in several areas: a simple yet powerful prototype-based object model for mainstream programming, many compilation techniques including customization, splitting, type prediction, polymorphic inline caches, adaptive optimization, and dynamic deoptimization, the application of cartoon animation to enhance the legibility of a dynamic graphical interface, an object-centered programming environment, and a user-interface construction framework that embodied a uniform use-mention distinction. Over the years, the project has published many papers and released four major versions of Self. Although the Self project ended in 1995, its implementation, animation, user interface toolkit architecture, and even its prototype object model impact computer science today (2006). Java virtual machines for desktop and laptop computers have adopted Self's implementation techniques, many user interfaces incorporate cartoon animation, several popular systems have adopted similar interface frameworks, and the prototype object model can be found in some of today's languages, including {JavaScript}. Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved.},
	Address = {New York, NY, USA},
	Author = {Ungar, David and Smith, Randall B.},
	Booktitle = {Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Citeulike-Article-Id = {5920806},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1238844.1238853},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1238844.1238853},
	Date-Added = {2013-12-04 16:53:05 +0000},
	Date-Modified = {2013-12-04 16:53:05 +0000},
	Doi = {10.1145/1238844.1238853},
	Isbn = {978-1-59593-766-7},
	Location = {San Diego, California},
	Posted-At = {2011-01-20 10:03:09},
	Priority = {2},
	Publisher = {ACM},
	Read = {1},
	Series = {HOPL III},
	Title = {{Self}},
	Url = {http://dx.doi.org/10.1145/1238844.1238853},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uLy4uL3BhcGVyL1VuZ2EwN2FhIFNlbGYucGRm0hcLGBlXTlMuZGF0YU8RAYQAAAAAAYQAAgAAA09TWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMroJ/NIKwAAAA4/DBFVbmdhMDdhYSBTZWxmLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEpaK9ycJlFFBERiAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAyugZ4wAAABEACAAAycJI9AAAAAEAEAAOPwwACxyKAAZRzQAC5owAAgA5T1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGFwZXI6AFVuZ2EwN2FhIFNlbGYucGRmAAAOACQAEQBVAG4AZwBhADAANwBhAGEAIABTAGUAbABmAC4AcABkAGYADwAIAAMATwBTAFgAEgAxVXNlcnMvY2FtaS1kYXRhL2VkdWNhdGlvbi9wYXBlci9VbmdhMDdhYSBTZWxmLnBkZgAAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwJDAkUCSgJVAl4CbAJwAncCgAKFApIClQKnAqoCrwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAKx},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1238844.1238853}}

@inproceedings{Rigo06a,
	Abstract = {The PyPy project seeks to prove both on a research and a practical level the feasibility of constructing a virtual machine (VM) for a dynamic language in a dynamic language - in this case, Python. The aim is to translate (i.e. compile) the VM to arbitrary target environments, ranging in level from C/Posix to Smalltalk/Squeak via Java and CLI/.NET, while still being of reasonable efficiency within these environments.A key tool to achieve this goal is the systematic reuse of the Python language as a system programming language at various levels of our architecture and translation process. For each level, we design a corresponding type system and apply a generic type inference engine - for example, the garbage collector is written in a style that manipulates simulated pointer and address objects, and when translated to C these operations become C-level pointer and address instructions.},
	Address = {New York, NY, USA},
	Author = {Rigo, Armin and Pedroni, Samuele},
	Booktitle = {OOPSLA '06: Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications},
	Citeulike-Article-Id = {4464460},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1176753},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1176617.1176753},
	Date-Added = {2013-12-04 16:53:01 +0000},
	Date-Modified = {2013-12-04 16:53:01 +0000},
	Doi = {10.1145/1176617.1176753},
	Isbn = {1-59593-491-X},
	Location = {Portland, Oregon, USA},
	Pages = {944--953},
	Posted-At = {2010-08-15 16:00:00},
	Priority = {2},
	Publisher = {ACM},
	Title = {{PyPy}'s approach to virtual machine construction},
	Url = {http://dx.doi.org/10.1145/1176617.1176753},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRy4uLy4uL3BhcGVyL1JpZ28wNmEgUHlQeSdzIGFwcHJvYWNoIHRvIHZpcnR1YWwgbWFjaGluZSBjb25zdHJ1Y3Rpb24ucGRm0hcLGBlXTlMuZGF0YU8RAhAAAAAAAhAAAgAAA09TWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMroJ/NIKwAAAA4/DB9SaWdvMDZhIFB5UHkncyBhcHByb2EjRTQwOUUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADkCeyBTBAwAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAyugZ4wAAABEACAAAyBSk4wAAAAEAEAAOPwwACxyKAAZRzQAC5owAAgBHT1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGFwZXI6AFJpZ28wNmEgUHlQeSdzIGFwcHJvYSNFNDA5RS5wZGYAAA4AeAA7AFIAaQBnAG8AMAA2AGEAIABQAHkAUAB5ACcAcwAgAGEAcABwAHIAbwBhAGMAaAAgAHQAbwAgAHYAaQByAHQAdQBhAGwAIABtAGEAYwBoAGkAbgBlACAAYwBvAG4AcwB0AHIAdQBjAHQAaQBvAG4ALgBwAGQAZgAPAAgAAwBPAFMAWAASAFtVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL1JpZ28wNmEgUHlQeSdzIGFwcHJvYWNoIHRvIHZpcnR1YWwgbWFjaGluZSBjb25zdHJ1Y3Rpb24ucGRmAAATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOANgA3QDlAvkC+wMAAwsDFAMiAyYDLQM2AzsDSANLA10DYANlAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA2c=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1176617.1176753}}

@inproceedings{Unga05a,
	Address = {New York, NY, USA},
	Author = {Ungar, David and Spitz, Adam and Ausch, Alex},
	Booktitle = {OOPSLA '05: Companion to the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2013-12-04 16:52:53 +0000},
	Date-Modified = {2013-12-04 16:52:53 +0000},
	Doi = {10.1145/1094855.1094865},
	Isbn = {1-59593-193-7},
	Keywords = {klein},
	Location = {San Diego, CA, USA},
	Pages = {11--20},
	Publisher = {ACM},
	Rating = {5},
	Read = {1},
	Title = {Constructing a metacircular Virtual machine in an exploratory programming environment},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QbS4uLy4uL3BhcGVyL1VuZ2EwNWEgQ29uc3RydWN0aW5nIGEgbWV0YWNpcmN1bGFyIFZpcnR1YWwgbWFjaGluZSBpbiBhbiBleHBsb3JhdG9yeSBwcm9ncmFtbWluZyBlbnZpcm9ubWVudC5wZGbSFwsYGVdOUy5kYXRhTxECggAAAAACggACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH1VuZ2EwNWEgQ29uc3RydWN0aW4jNUNENzRBMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXNdKLLDmYwUERGIAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADLDlggAAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoAVW5nYTA1YSBDb25zdHJ1Y3RpbiM1Q0Q3NEEyLnBkZgAADgDEAGEAVQBuAGcAYQAwADUAYQAgAEMAbwBuAHMAdAByAHUAYwB0AGkAbgBnACAAYQAgAG0AZQB0AGEAYwBpAHIAYwB1AGwAYQByACAAVgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAIABpAG4AIABhAG4AIABlAHgAcABsAG8AcgBhAHQAbwByAHkAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABlAG4AdgBpAHIAbwBuAG0AZQBuAHQALgBwAGQAZgAPAAgAAwBPAFMAWAASAIFVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL1VuZ2EwNWEgQ29uc3RydWN0aW5nIGEgbWV0YWNpcmN1bGFyIFZpcnR1YWwgbWFjaGluZSBpbiBhbiBleHBsb3JhdG9yeSBwcm9ncmFtbWluZyBlbnZpcm9ubWVudC5wZGYAABMAAS8AABUAAgAL//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A/gEDAQsDkQOTA5gDowOsA7oDvgPFA84D0wPgA+MD9QP4A/0AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD/w==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1094855.1094865}}

@proceedings{Male96a,
	Abstract = {The efficient implementation of behaviorally reflective languages imposes a formidable challenge. By definition, behavioral reflection allows a program to modify even at runtime, its own code as well as the semantics and the implementation of its own programming language. This late-binding of the language semantics favors interpretive techniques, but compilers are absolutely necessary to make reflective languages efficient and therefore of real interest. The goals of this tutorial are to give the picture of the state of the art in the efficient implementation of behavioral reflection, to review the main issues in going from interpreter-based to compiler-based implementations and to propose new avenues towards the realization of this objective. Our tutorial is aimed at a large audience of reflective language implementors, in either object-oriented, functional or even logic programming. To make our point widely applicable, we avoid fine grain technicalities. Rather we emphasize the common denominator of all reflective languages, we propose a clear and general problem statement, and we set up a wide-ranging research agenda},
	Address = {Xerox Palo Alto Research Center, San Francisco, CA},
	Annote = {Contains various definitions of terms related to reflection.
- Reflection
- reflective mechanism
- structural reflection
- behavioral reflection
- discrete and continous reflection
- binding, formal-binding time, actual binding time},
	Author = {Malenfant, J. and Jacques, M. and Demers, F. N.},
	Booktitle = {Proceedings of the Reflection '96 Conference},
	Citeulike-Article-Id = {6483507},
	Date-Added = {2013-12-04 16:52:46 +0000},
	Date-Modified = {2013-12-04 17:34:09 +0000},
	Keywords = {jamoma},
	Pages = {20},
	Posted-At = {2010-01-04 16:04:52},
	Priority = {2},
	Rating = {5},
	Read = {1},
	Title = {A tutorial on behavioral reflection and its implementation},
	Url = {http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/malenfant.pdf},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QUi4uLy4uL3BhcGVyL01hbGU5NmEgQSB0dXRvcmlhbCBvbiBiZWhhdmlvcmFsIHJlZmxlY3Rpb24gYW5kIGl0cyBpbXBsZW1lbnRhdGlvbi5wZGbSFwsYGVdOUy5kYXRhTxECMAAAAAACMAACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH01hbGU5NmEgQSB0dXRvcmlhbCAjNDRERDBEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARN0NnNXluGAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADNXk12AAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoATWFsZTk2YSBBIHR1dG9yaWFsICM0NEREMEQ5LnBkZgAADgCOAEYATQBhAGwAZQA5ADYAYQAgAEEAIAB0AHUAdABvAHIAaQBhAGwAIABvAG4AIABiAGUAaABhAHYAaQBvAHIAYQBsACAAcgBlAGYAbABlAGMAdABpAG8AbgAgAGEAbgBkACAAaQB0AHMAIABpAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ALgBwAGQAZgAPAAgAAwBPAFMAWAASAGZVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL01hbGU5NmEgQSB0dXRvcmlhbCBvbiBiZWhhdmlvcmFsIHJlZmxlY3Rpb24gYW5kIGl0cyBpbXBsZW1lbnRhdGlvbi5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDjAOgA8AMkAyYDKwM2Az8DTQNRA1gDYQNmA3MDdgOIA4sDkAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOS}}

@article{Van10a,
	Abstract = {Proxies are a powerful approach to implement meta-objects in object-oriented languages without having to resort to metacircular interpretation. We introduce such a meta-level {API} based on proxies for Javascript. We simultaneously introduce a set of design principles that characterize such {APIs} in general, and compare similar {APIs} of other languages in terms of these principles. We highlight how principled proxy-based {APIs} improve code robustness by avoiding interference between base and meta-level code that occur in more common reflective intercession mechanisms.},
	Address = {New York, NY, USA},
	Author = {Van Cutsem, Tom and Miller, Mark S.},
	Citeulike-Article-Id = {9886030},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1869638},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1899661.1869638},
	Date-Added = {2013-12-04 16:52:41 +0000},
	Date-Modified = {2013-12-04 16:52:41 +0000},
	Doi = {10.1145/1899661.1869638},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = oct,
	Pages = {59--72},
	Posted-At = {2011-10-10 12:11:46},
	Priority = {2},
	Publisher = {ACM},
	Title = {Proxies: design principles for robust object-oriented intercession {APIs}},
	Url = {http://dx.doi.org/10.1145/1899661.1869638},
	Volume = {45},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXi4uLy4uL3BhcGVyL1Zhbi0xMGEgUHJveGllcyBkZXNpZ24gcHJpbmNpcGxlcyBmb3Igcm9idXN0IG9iamVjdC1vcmllbnRlZCBpbnRlcmNlc3Npb24gQVBJcy5wZGbSFwsYGVdOUy5kYXRhTxECVAAAAAACVAACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH1Zhbi0xMGEgUHJveGllcyBkZXNpIzY1MUQ0Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlHUzLDmYwAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADLDlggAAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoAVmFuLTEwYSBQcm94aWVzIGRlc2kjNjUxRDRDLnBkZgAADgCmAFIAVgBhAG4ALQAxADAAYQAgAFAAcgBvAHgAaQBlAHMAIABkAGUAcwBpAGcAbgAgAHAAcgBpAG4AYwBpAHAAbABlAHMAIABmAG8AcgAgAHIAbwBiAHUAcwB0ACAAbwBiAGoAZQBjAHQALQBvAHIAaQBlAG4AdABlAGQAIABpAG4AdABlAHIAYwBlAHMAcwBpAG8AbgAgAEEAUABJAHMALgBwAGQAZgAPAAgAAwBPAFMAWAASAHJVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL1Zhbi0xMGEgUHJveGllcyBkZXNpZ24gcHJpbmNpcGxlcyBmb3Igcm9idXN0IG9iamVjdC1vcmllbnRlZCBpbnRlcmNlc3Npb24gQVBJcy5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDvAPQA/ANUA1YDWwNmA28DfQOBA4gDkQOWA6MDpgO4A7sDwAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPC},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1899661.1869638}}

@article{Cham89a,
	Abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.   To compensate for the absence of classes, our system uses implementation-level  maps  to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles  multiple versions  of a source method, each  customized  according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and  inline  all messages sent to self.  Message splitting  and  type prediction  extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.   Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.},
	Address = {New York, NY, USA},
	Author = {Chambers, C. and Ungar, D. and Lee, E.},
	Citeulike-Article-Id = {556549},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=74878.74884},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/74878.74884},
	Date-Added = {2013-12-04 16:52:26 +0000},
	Date-Modified = {2013-12-04 16:52:26 +0000},
	Doi = {10.1145/74878.74884},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = {October},
	Number = {10},
	Pages = {49--70},
	Posted-At = {2010-08-19 07:48:13},
	Priority = {2},
	Publisher = {ACM},
	Title = {An efficient implementation of {SELF} a dynamically-typed object-oriented language based on prototypes},
	Url = {http://dx.doi.org/10.1145/74878.74884},
	Volume = {24},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QfC4uLy4uL3BhcGVyL0NoYW04OWEgQW4gZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIFNFTEYgYSBkeW5hbWljYWxseS10eXBlZCBvYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2UgYmFzZWQgb24gcHJvdG90eXBlcy5wZGbSFwsYGVdOUy5kYXRhTxECrgAAAAACrgACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAADj8MH0NoYW04OWEgQW4gZWZmaWNpZW50ICNFM0ZGNS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOP/XIkgqYAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADK6BnjAAAAEQAIAADIke54AAAAAQAQAA4/DAALHIoABlHNAALmjAACAEdPU1g6VXNlcnM6AGNhbWktZGF0YToAZWR1Y2F0aW9uOgBwYXBlcjoAQ2hhbTg5YSBBbiBlZmZpY2llbnQgI0UzRkY1LnBkZgAADgDiAHAAQwBoAGEAbQA4ADkAYQAgAEEAbgAgAGUAZgBmAGkAYwBpAGUAbgB0ACAAaQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuACAAbwBmACAAUwBFAEwARgAgAGEAIABkAHkAbgBhAG0AaQBjAGEAbABsAHkALQB0AHkAcABlAGQAIABvAGIAagBlAGMAdAAtAG8AcgBpAGUAbgB0AGUAZAAgAGwAYQBuAGcAdQBhAGcAZQAgAGIAYQBzAGUAZAAgAG8AbgAgAHAAcgBvAHQAbwB0AHkAcABlAHMALgBwAGQAZgAPAAgAAwBPAFMAWAASAJBVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL0NoYW04OWEgQW4gZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIFNFTEYgYSBkeW5hbWljYWxseS10eXBlZCBvYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2UgYmFzZWQgb24gcHJvdG90eXBlcy5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgENARIBGgPMA84D0wPeA+cD9QP5BAAECQQOBBsEHgQwBDMEOAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQ6},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/74878.74884}}

@book{Blac09a,
	Abstract = {Pharo by Example, intended for both students and
                  developers, will guide you gently through the Pharo
                  language and environment by means of a series of
                  examples and exercises. This book is made available
                  under the Creative Commons Attribution-ShareAlike
                  3.0 license.},
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {book},
	Author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Date-Added = {2013-12-04 16:52:19 +0000},
	Date-Modified = {2013-12-04 16:52:19 +0000},
	Inria = {ADAM},
	Isbn = {978-3-9523341-4-0},
	Keywords = {olit scg09 scg-pub jb09 snf-none skip-doi},
	Medium = {2},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {{Pharo} by Example},
	Url = {http://pharobyexample.org},
	Year = {2009},
	Bdsk-Url-1 = {http://pharobyexample.org}}

@electronic{Mira99a,
	Abstract = {Smalltalk-80 provides a reification of execution state in the form of context objects which represent procedure activation records. Smalltalk-80 also provides full closures with indefinite extent. These features pose interesting implementation challenges because a na\"{i}ve implementation entails instantiating context objects on every method activation, but typical Smalltalk-80 programs obey stack discipline for the vast majority of activations. Both software and hardware implementations of Smalltalk-80 have mapped contexts and closure activations to stack frames but not without overhead when compared to traditional stack-based activation and return in  '' conventional '' languages. We present a new design for contexts and closures that significantly reduces the overall overhead of these features and imposes overhead only in code that actually manipulates execution state in the form of contexts.},
	Author = {Miranda, Eliot},
	Citeulike-Article-Id = {7652821},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597},
	Date-Added = {2013-12-04 16:51:39 +0000},
	Date-Modified = {2013-12-04 16:51:39 +0000},
	Doi = {10.1.1.42.6597},
	Posted-At = {2010-08-15 15:25:36},
	Priority = {2},
	Title = {Context Management in {VisualWorks} 5i},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QPC4uLy4uL3BhcGVyL01pcmE5OWEgQ29udGV4dCBNYW5hZ2VtZW50IGluIFZpc3VhbFdvcmtzIDVpLnBkZtIXCxgZV05TLmRhdGFPEQHuAAAAAAHuAAIAAANPU1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK6CfzSCsAAAAOPwwfTWlyYTk5YSBDb250ZXh0IE1hbmFnI0U0MDdELnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5Afcg7o5sAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAMroGeMAAAARAAgAAMg7h3sAAAABABAADj8MAAscigAGUc0AAuaMAAIAR09TWDpVc2VyczoAY2FtaS1kYXRhOgBlZHVjYXRpb246AHBhcGVyOgBNaXJhOTlhIENvbnRleHQgTWFuYWcjRTQwN0QucGRmAAAOAGIAMABNAGkAcgBhADkAOQBhACAAQwBvAG4AdABlAHgAdAAgAE0AYQBuAGEAZwBlAG0AZQBuAHQAIABpAG4AIABWAGkAcwB1AGEAbABXAG8AcgBrAHMAIAA1AGkALgBwAGQAZgAPAAgAAwBPAFMAWAASAFBVc2Vycy9jYW1pLWRhdGEvZWR1Y2F0aW9uL3BhcGVyL01pcmE5OWEgQ29udGV4dCBNYW5hZ2VtZW50IGluIFZpc3VhbFdvcmtzIDVpLnBkZgATAAEvAAAVAAIAC///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAM0A0gDaAswCzgLTAt4C5wL1AvkDAAMJAw4DGwMeAzADMwM4AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAzo=},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597}}

@book{Kicz91a,
	Author = {Gregor Kiczales and Jim des Rivi\`eres and Daniel G. Bobrow},
	Isbn = {0-262-11158-6},
	Publisher = {MIT Press},
	Title = {The Art of the Metaobject Protocol},
	Year = {1991}}

@inproceedings{Vran12a,
	Abstract = {Programming languages are still evolving, and
                   programming languages and language features are being
                   designed and implemented every year. Since it is not
                   a trivial task to provide a runtime system for a new
                   language, existing runtime systems such as the Java
                   Virtual Machine or the Common Language Runtime are
                   used to host the new language. However, most of the
                   high-performance runtime systems were designed for a
                   specific language with a specific semantics.
                   Therefore, if the new language semantics differs from
                   the semantics hard-coded in a runtime system, it has
                   to be emulated on top of features supported by the
                   runtime. The emulation causes performance overhead.
                   To overcome the limitations of an emulation, a
                   runtime system may provide a meta-object protocol to
                   alter the runtime semantics. The protocol should
                   fulfill opposing goals: it should be flexible, easy
                   to use, fast and easy to implement at the same time.
                   We propose a simple meta-object protocol for
                   customization of a method lookup in Smalltalk. A
                   programmer may define his own custom method lookup
                   routine in Smalltalk and let the runtime system to
                   call it when needed. Therefore there is no need to
                   modify the runtime system itself. Our solution
                   provides reasonable performance thanks to low-level
                   support in a runtime system, nevertheless the changes
                   to the runtime system are small and local. At the
                   same time, it provides the flexibility to implement a
                   wide range of features present in modern programming
                   languages. The presented approach has been
                   implemented and validated on a Smalltalk virtual
                   machine.},
	Address = {Berlin, Heidelberg},
	Author = {Vran\'{y}, Jan and Kur\v{s}, Jan and Gittinger, Claus},
	Booktitle = {Proceedings of the 50th international conference on Objects, Models, Components, Patterns},
	Doi = {10.1007/978-3-642-30561-0\_10},
	Isbn = {978-3-642-30560-3},
	Pages = {124--139},
	Publisher = {Springer-Verlag},
	Series = {TOOLS'12},
	Title = {Efficient method lookup customization for {Smalltalk}},
	Url = {http://dx.doi.org/10.1007/978-3-642-30561-0\_10},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-642-30561-0%5C_10}}

@inproceedings{Fram09a,
	Abstract = {The power of high-level languages lies in their
                   abstraction over hardware and software complexity,
                   leading to greater security, better reliability, and
                   lower development costs. However, opaque abstractions
                   are often show-stoppers for systems programmers,
                   forcing them to either break the abstraction, or more
                   often, simply give up and use a different language.
                   This paper addresses the challenge of opening up a
                   high-level language to allow practical low-level
                   programming without forsaking integrity or
                   performance. The contribution of this paper is
                   three-fold: 1) we draw together common threads in a
                   diverse literature, 2) we identify a framework for
                   extending high-level languages for low-level
                   programming, and 3) we show the power of this
                   approach through concrete case studies. Our framework
                   leverages just three core ideas: extending semantics
                   via intrinsic methods, extending types via unboxing
                   and architectural-width primitives, and controlling
                   semantics via scoped semantic regimes. We develop
                   these ideas through the context of a rich literature
                   and substantial practical experience. We show that
                   they provide the power necessary to implement
                   substantial artifacts such as a high-performance
                   virtual machine, while preserving the software
                   engineering benefits of the host language. The time
                   has come for high-level low-level programming to be
                   taken more seriously: 1) more projects now use
                   high-level languages for systems programming, 2)
                   increasing architectural heterogeneity and
                   parallelism heighten the need for abstraction, and 3)
                   a new generation of high-level languages are under
                   development and ripe to be influenced.},
	Address = {New York, NY, USA},
	Author = {Frampton, Daniel and Blackburn, Stephen M. and Cheng, Perry and Garner, Robin J. and Grove, David and Eliot and Salishev, Sergey I.},
	Booktitle = {Proceedings of the 2009 ACM SIGPLAN/SIGOPS international conference on Virtual execution environments},
	Doi = {10.1145/1508293.1508305},
	Isbn = {978-1-60558-375-4},
	Pages = {81--90},
	Publisher = {ACM},
	Series = {VEE '09},
	Title = {Demystifying magic: high-level low-level programming},
	Url = {http://dx.doi.org/10.1145/1508293.1508305},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1508293.1508305}}

@inproceedings{Alpe99a,
	Abstract = {Jalape\~{n}o is a virtual machine for
                   Java{\texttrademark} servers written in {Java.A}
                   running Java program involves four layers of
                   functionality: the user code, the virtual-machine,
                   the operating system, and the hardware. By drawing
                   the Java / {non-Java} boundary below the virtual
                   machine rather than above it, Jalape\~{n}o reduces
                   the boundary-crossing overhead and opens up more
                   opportunities for {optimization.To} get Jalape\~{n}o
                   started, a boot image of a working Jalape\~{n}o
                   virtual machine is concocted and written to a file.
                   Later, this file can be loaded into memory and
                   executed. Because the boot image consists entirely of
                   Java objects, it can be concocted by a Java program
                   that runs in any {JVM}. This program uses reflection
                   to convert the boot image into Jalape\~{n}o's object
                   {format.A} special {MAGIC} class allows unsafe casts
                   and direct access to the hardware. Methods of this
                   class are recognized by Jalape\~{n}o's three
                   compilers, which ignore their bytecodes and emit
                   special-purpose machine code. User code will not be
                   allowed to call {MAGIC} methods so Java's integrity
                   is {preserved.A} small {non-Java} program is used to
                   start up a boot image and as an interface to the
                   operating {system.Java}'s programming features ---
                   object orientation, type safety, automatic memory
                   management --- greatly facilitated development of
                   Jalape\~{n}o. However, we also discovered some of the
                   language's limitations.},
	Address = {New York, NY, USA},
	Author = {Alpern, Bowen and Attanasio, C. R. and Cocchi, Anthony and Lieber, Derek and Smith, Stephen and Ngo, Ton and Barton, John J. and Hummel, Susan F. and Sheperd, Janice C. and Mergen, Mark},
	Booktitle = {Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Doi = {10.1145/320384.320418},
	Isbn = {1-58113-238-7},
	Pages = {314--324},
	Publisher = {ACM},
	Series = {OOPSLA '99},
	Title = {Implementing {Jalape{\~n}o} in {Java}},
	Url = {http://dx.doi.org/10.1145/320384.320418},
	Year = {1999},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/320384.320418}}

@inproceedings{Maes87a,
	Author = {Pattie Maes},
	Booktitle = {Proceedings OOPSLA '87, ACM SIGPLAN Notices},
	Doi = {10.1145/38765.38821},
	Month = dec,
	Pages = {147--155},
	Title = {Concepts and Experiments in Computational Reflection},
	Volume = {22},
	Year = {1987},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/38765.38821}}

@article{Wimm13a,
	Abstract = {A highly productive platform accelerates the
                   production of research results. The design of a
                   Virtual Machine ({VM}) written in the
                   Java{\texttrademark} programming language can be
                   simplified through exploitation of interfaces, type
                   and memory safety, automated memory management
                   (garbage collection), exception handling, and
                   reflection. Moreover, modern Java {IDEs} offer
                   time-saving features such as refactoring,
                   auto-completion, and code navigation. Finally, Java
                   annotations enable compiler extensions for low-level
                   '' systems programming'' while retaining {IDE}
                   compatibility. These techniques collectively make
                   complex system software more '' approachable'' than
                   has been typical in the past. The Maxine {VM}, a
                   metacircular Java {VM} implementation, has
                   aggressively used these features since its inception.
                   A co-designed companion tool, the Maxine Inspector,
                   offers integrated debugging and visualization of all
                   aspects of the {VM}'s runtime state. The Inspector's
                   implementation exploits advanced Java language
                   features, embodies intimate knowledge of the {VM}'s
                   design, and even reuses a significant amount of {VM}
                   code directly. These characteristics make Maxine a
                   highly approachable {VM} research platform and a
                   productive basis for research and teaching.},
	Address = {New York, NY, USA},
	Author = {Wimmer, Christian and Haupt, Michael and Van De Vanter, Michael L. and Jordan, Mick and Dayn\`{e}s, Laurent and Simon, Douglas},
	Doi = {10.1145/2400682.2400689},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Month = jan,
	Number = {4},
	Publisher = {ACM},
	Title = {{Maxine}: An approachable virtual machine for, and in, {Java}},
	Url = {http://dx.doi.org/10.1145/2400682.2400689},
	Volume = {9},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2400682.2400689}}

@inproceedings{Inga97a,
	Author = {Ingalls, Dan and Kaehler, Ted and Maloney, John and Wallace, Scott and Kay, Alan},
	Booktitle = {OOPSLA'97: Proceedings of the 12th International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	Doi = {10.1145/263700.263754},
	Month = nov,
	Pages = {318--326},
	Publisher = {ACM Press},
	Title = {Back to the Future: The Story of {Squeak}, a Practical {Smalltalk} Written in Itself},
	Url = {http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/ squeak.html},
	Year = {1997},
	Bdsk-Url-1 = {http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/%20squeak.html},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/263700.263754}}

@inproceedings{Mira11a,
	Author = {Eliot Miranda},
	Booktitle = {VMIL '11: Proceedings of the 5th workshop on Virtual machines and intermediate languages for emerging modularization mechanisms},
	Publisher = {ACM},
	Title = {The {Cog} {Smalltalk} Virtual Machine},
	Year = {2011}}

@inproceedings{Brun13a,
	Abstract = {{Foreign-Function-Interfaces (FFIs) are a
                   prerequisite for close system integration of a
                   high-level language. With FFIs the high-level
                   environment interacts with low-level functions
                   allowing for a unique combination of features. This
                   duality has a strong impact on the implementation of
                   the FFI: it has to be flexible and fast at the same
                   time. We propose NativeBoost a language-side approach
                   to FFIs that only requires minimal changes to the VM.
                   NativeBoost directly creates specific native code at
                   language-side and thus combines the flexibility of a
                   language-side library with the performance of a
                   native plugin.}},
	Address = {Annecy, France},
	Author = {Bruni, Camillo and Ducasse, St{\'e}phane and Stasenko, Igor and Fabresse, Luc},
	Booktitle = {{International Workshop on Smalltalk Technologies}},
	Language = {Anglais},
	Month = sep,
	Title = {{Language-side Foreign Function Interfaces with NativeBoost}},
	Url = {http://hal.inria.fr/hal-00840781},
	Year = {2013},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00840781}}

@inproceedings{Denk10a,
	Abstract = {A feature represents a functional requirement
                   fulfilled by a system. Since many maintenance tasks
                   are expressed in terms of features, it is important
                   to establish the correspondence between a feature and
                   its implementation in source code. Traditional
                   approaches to establish this correspondence exercise
                   features to generate a trace of runtime events, which
                   is then processed by post-mortem analysis. These
                   approaches typically generate large amounts of data
                   to analyze. Due to their static nature, these
                   approaches do not support incremental and interactive
                   analysis of features. We propose a radically
                   different approach called live feature analysis,
                   which provides a model at runtime of features. Our
                   approach analyzes features on a running system and
                   also makes it possible to grow feature
                   representations by exercising different scenarios of
                   the same feature, and identifies execution elements
                   even to the sub-method level. We describe how live
                   feature analysis is implemented effectively by
                   annotating structural representations of code based
                   on abstract syntax trees. We illustrate our live
                   analysis with a case study where we achieve a more
                   complete feature representation by exercising and
                   merging variants of feature behavior and demonstrate
                   the efficiency or our technique with benchmarks.},
	Author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of MODELS 2010 Part II},
	Doi = {10.1007/978-3-642-16129-2\_11},
	Isbn = {978-3-642-16128-5},
	Month = oct,
	Pages = {138--152},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Modeling Features at Runtime},
	Url = {http://rmod.lille.inria.fr/archives/papers/ Denk10a-Models10-FeatureModels.pdf},
	Volume = {6395},
	Year = {2010},
	Bdsk-Url-1 = {http://rmod.lille.inria.fr/archives/papers/%20Denk10a-Models10-FeatureModels.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-16129-2%5C_11}}

@unpublished{Char13a,
	Abstract = {{Modern languages are typically supported by managed
                   runtimes (Virtual Machines). Since VMs have to deal
                   with many concepts such as memory management,
                   abstract execution model and scheduling, they tend to
                   be very complex. Additionally, VMs have to meet
                   strong performance requirements. This demand of
                   performance is one of the main reasons why many VMs
                   are built statically. Thus, design decisions are
                   frozen at compile time preventing changes at runtime.
                   One clear example is the impossibility to dynamically
                   adapt or change primitives of the VM once it has been
                   compiled. In this work we present a toolchain that
                   allows for altering and configuring components such
                   as primitives and plug-ins at runtime. The main
                   contribution is Waterfall, a dynamic and reflective
                   translator from Slang, a restricted subset of
                   Smalltalk, to native code. Waterfall generates
                   primitives on demand and executes them on the fly. We
                   validate our approach by implementing dynamic
                   primitive modification and runtime customization of
                   VM plug-ins.}},
	Author = {Chari, Guido and Garbervetsky, Diego and Bruni, Camillo and Denker, Marcus and Ducasse, St{\'e}phane},
	Language = {English},
	Month = {Sep},
	Note = {Preprint: \url{http://hal.inria.fr/hal-00871353}},
	Title = {{Waterfall: Primitives Generation on the Fly}},
	Url = {http://hal.inria.fr/hal-00871353},
	Year = {2013},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00871353}}

@book{Appe98a,
	Address = {New York, NY, USA},
	Author = {Appel, Andrew W.},
	Isbn = {0-521-58388-8},
	Publisher = {Cambridge University Press},
	Title = {Modern compiler implementation in {Java}},
	Year = {1998}}

@book{Gold83a,
	Address = {Reading, Mass.},
	Author = {Adele Goldberg and David Robson},
	Isbn = {0-201-13688-0},
	Month = may,
	Publisher = {Addison Wesley},
	Title = {{Smalltalk-80}: the Language and its Implementation},
	Url = {http://stephane.ducasse.free.fr/FreeBooks/BlueBook/ Bluebook.pdf},
	Year = {1983},
	Bdsk-Url-1 = {http://stephane.ducasse.free.fr/FreeBooks/BlueBook/%20Bluebook.pdf}}

@article{Ayco03a,
	Abstract = {Software systems have been using "just-in-time"
                   compilation (JIT) techniques since the 1960s.
                   Broadly, JIT compilation includes any translation
                   performed dynamically, after a program has started
                   execution. We examine the motivation behind JIT
                   compilation and constraints imposed on JIT
                   compilation systems, and present a classification
                   scheme for such systems. This classification emerges
                   as we survey forty years of JIT work, from
                   1960--2000.},
	Address = {New York, NY, USA},
	Author = {Aycock, John},
	Doi = {10.1145/857076.857077},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Month = {June},
	Number = {2},
	Pages = {97--113},
	Publisher = {ACM},
	Title = {A brief history of just-in-time},
	Url = {http://dx.doi.org/10.1145/857076.857077},
	Volume = {35},
	Year = {2003},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/857076.857077}}

@comment{BibDesk URL Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>URL</key>
		<string>file://localhost/Users/cami-data/education/paper/cami.bib</string>
		<key>group name</key>
		<string>cami.bib</string>
	</dict>
</array>
</plist>
}}
