%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/


%% Created for Camillo Bruni at 2014-05-19 19:22:37 +0200 


%% Saved with string encoding Unicode (UTF-8) 



@article{McGh98a,
	Abstract = {Key to the central promise inherent in Java technology-"write once, run anywhere"-is the fact that Java programs run on the Java virtual machine, insulating them from any contact with the underlying hardware. Consequently, Java programs must execute indirectly through a translation layer built into the Java virtual machine. Translation essentially converts Java virtual machine instructions (called byte-codes) into corresponding machine-specific binary instructions. Bytecode is a single image of a program that will execute identically (in principle) on any system equipped with a {JVM}. The first step toward the development of a new class of Java processors was the creation of the bytecode execution engine itself, called the {picoJava} core. {PicoJava} directly executes Java bytecode instructions and provides hardware support for other essential functions of the {JVM}. Executing bytecode instructions in hardware eliminates the need for dynamic translation, thus extending the useful range of Java bytecode programs to embedded environments. By the end of 1998, Java processors like Sun's {microJava} 701 should be available for evaluation from several licensees of the {picoJava} core technology},
	Address = {Los Alamitos, CA, USA},
	Author = {McGhan, Harlan and O'Connor, Mike},
	Booktitle = {Computer},
	Citeulike-Article-Id = {4017931},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=621089},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1109/2.722273},
	Citeulike-Linkout-2 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=722273},
	Date-Added = {2014-03-29 10:49:13 +0000},
	Date-Modified = {2014-03-29 10:49:13 +0000},
	Doi = {10.1109/2.722273},
	Issn = {0018-9162},
	Journal = {Computer},
	Month = oct,
	Number = {10},
	Pages = {22--30},
	Posted-At = {2014-03-29 10:48:11},
	Priority = {2},
	Publisher = {IEEE Computer Society Press},
	Title = {{PicoJava}: A Direct Execution Engine For Java Bytecode},
	Url = {http://dx.doi.org/10.1109/2.722273},
	Volume = {31},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QTC4uLy4uL3BhcGVyL01jR2g5OGEgUGljb0phdmEgQSBEaXJlY3QgRXhlY3V0aW9uIEVuZ2luZSBGb3IgSmF2YSBCeXRlY29kZS5wZGbSFwsYGVdOUy5kYXRhTxECYgAAAAACYgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH01jR2g5OGEgUGljb0phdmEgQSBEaSNCRDE2OC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0WjPXGOnAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADPXFWXAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoATWNHaDk4YSBQaWNvSmF2YSBBIERpI0JEMTY4LnBkZgAADgCCAEAATQBjAEcAaAA5ADgAYQAgAFAAaQBjAG8ASgBhAHYAYQAgAEEAIABEAGkAcgBlAGMAdAAgAEUAeABlAGMAdQB0AGkAbwBuACAARQBuAGcAaQBuAGUAIABGAG8AcgAgAEoAYQB2AGEAIABCAHkAdABlAGMAbwBkAGUALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAG1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9NY0doOThhIFBpY29KYXZhIEEgRGlyZWN0IEV4ZWN1dGlvbiBFbmdpbmUgRm9yIEphdmEgQnl0ZWNvZGUucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAN0A4gDqA1ADUgNXA2IDawN5A30DhAONA5IDnwOiA7QDtwO8AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA74=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/2.722273}}

@inproceedings{Tant08a,
	Abstract = {Context-oriented programming proposes to treat execution context explicitly and to provide means for context-dependent adaptation at runtime. There are many mechanisms that can be used to make either variable bindings or application code adapt dynamically, like dynamically-scoped variables, dynamic layer activation, and contextual dispatch. There are no means however, to make actual values be context-dependent. This means that side effects engendered by dynamically-activated adaptations are potentially global. We propose contextual values: values that actually depend on the context in which they are looked at and modified. We explore how contextual values can be provided, either as a simple library or directly into the language through different designs, for which we provide the operational semantics in the form of Scheme interpreters. Being able to scope side effects to certain contexts is a step forward for context-oriented programming, and can have interesting applications in other areas like security and dynamic software evolution.},
	Address = {New York, NY, USA},
	Author = {Tanter, \'{E}ric},
	Booktitle = {Proceedings of the 2008 Symposium on Dynamic Languages},
	Citeulike-Article-Id = {6414706},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1408681.1408684},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1408681.1408684},
	Date-Added = {2014-03-29 10:00:00 +0000},
	Date-Modified = {2014-03-29 10:00:00 +0000},
	Doi = {10.1145/1408681.1408684},
	Isbn = {978-1-60558-270-2},
	Location = {Paphos, Cyprus},
	Pages = {1--10},
	Posted-At = {2014-03-29 09:58:15},
	Priority = {2},
	Publisher = {ACM},
	Series = {DLS '08},
	Title = {Contextual Values},
	Url = {http://dx.doi.org/10.1145/1408681.1408684},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QKS4uLy4uL3BhcGVyL1RhbnQwOGEgQ29udGV4dHVhbCBWYWx1ZXMucGRm0hcLGBlXTlMuZGF0YU8RAfYAAAAAAfYAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx1UYW50MDhhIENvbnRleHR1YWwgVmFsdWVzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9SIz1xYkgAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAz1xKggAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAX1NhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFRhbnQwOGEgQ29udGV4dHVhbCBWYWx1ZXMucGRmAAAOADwAHQBUAGEAbgB0ADAAOABhACAAQwBvAG4AdABlAHgAdAB1AGEAbAAgAFYAYQBsAHUAZQBzAC4AcABkAGYADwAgAA8AUwBhAG0AcwB1AG4AZwAgAFMAUwBEACAAOAA0ADAAEgBKVXNlcnMvY2FtaWxsb2JydW5pL0RvY3VtZW50cy9lZHVjYXRpb24vcGFwZXIvVGFudDA4YSBDb250ZXh0dWFsIFZhbHVlcy5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgC6AL8AxwLBAsMCyALTAtwC6gLuAvUC/gMDAxADEwMlAygDLQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMv},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1408681.1408684}}

@inproceedings{Unga84a,
	Abstract = {Smalltalk on a {RISC} ({SOAR}) is a simple, Von Neumann computer that is designed to execute the Smalltalk-80 system much faster than existing {VLSI} microcomputers. The Smalltalk-80 system is a highly productive programming environment but poses tough challenges for implementors: dynamic data typing, a high level instruction set, frequent and expensive procedure calls, and object-oriented storage management. {SOAR} compiles programs to a low level, efficient instruction set. Parallel tag checks permit high performance for the simple common cases and cause traps to software routines for the complex cases. Parallel register initialization and multiple on-chip register windows speed procedure calls. Sophisticated software techniques relieve the hardware of the burden of managing objects. We have initial evaluations of the effectiveness of the {SOAR} architecture by compiling and simulating benchmarks, and will prove {SOAR}'s feasibility by fabricating a 35,000-transistor {SOAR} chip. These early results suggest that a Reduced Instruction Set Computer can provide high performance in an exploratory programming environment.},
	Address = {New York, NY, USA},
	Author = {Ungar, David and Blau, Ricki and Foley, Peter and Samples, Dain and Patterson, David},
	Booktitle = {Proceedings of the 11th Annual International Symposium on Computer Architecture},
	Citeulike-Article-Id = {13117263},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=808182},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/800015.808182},
	Date-Added = {2014-03-27 10:37:24 +0000},
	Date-Modified = {2014-03-27 10:37:24 +0000},
	Doi = {10.1145/800015.808182},
	Isbn = {0-8186-0538-3},
	Pages = {188--197},
	Posted-At = {2014-03-27 10:36:51},
	Priority = {2},
	Publisher = {ACM},
	Series = {ISCA '84},
	Title = {Architecture of {SOAR}: Smalltalk on a {RISC}},
	Url = {http://dx.doi.org/10.1145/800015.808182},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QQC4uLy4uL3BhcGVyL1VuZ2E4NGEgQXJjaGl0ZWN0dXJlIG9mIFNPQVIgU21hbGx0YWxrIG9uIGEgUklTQy5wZGbSFwsYGVdOUy5kYXRhTxECPgAAAAACPgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1VuZ2E4NGEgQXJjaGl0ZWN0dXJlICNCRDQ5Ni5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL1JbPWb3OAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADPWa++AAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAVW5nYTg0YSBBcmNoaXRlY3R1cmUgI0JENDk2LnBkZgAADgBqADQAVQBuAGcAYQA4ADQAYQAgAEEAcgBjAGgAaQB0AGUAYwB0AHUAcgBlACAAbwBmACAAUwBPAEEAUgAgAFMAbQBhAGwAbAB0AGEAbABrACAAbwBuACAAYQAgAFIASQBTAEMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGFVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9VbmdhODRhIEFyY2hpdGVjdHVyZSBvZiBTT0FSIFNtYWxsdGFsayBvbiBhIFJJU0MucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOANEA1gDeAyADIgMnAzIDOwNJA00DVANdA2IDbwNyA4QDhwOMAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA44=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/800015.808182}}

@inproceedings{Stef84a,
	Abstract = {High performance facilities to interpret {LISP} represent an ever increasing request even for {minis.This} paper presents a {LISP} hardware structure conceived to be implemented in a general purpose mini system called {DIAGRAM}.The {LISP} structure had to be adapted to the system technological requirements and {size.The} data structure and the instruction set concerning the basic machine are also presented.},
	Address = {New York, NY, USA},
	Author = {Stefan, G. and Paun, A. and Bistriceanu, V. and Birnbaum, A.},
	Booktitle = {Proceedings of the 1984 ACM Symposium on LISP and Functional Programming},
	Citeulike-Article-Id = {13117259},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=800055.802028},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/800055.802028},
	Date-Added = {2014-03-27 10:27:55 +0000},
	Date-Modified = {2014-03-27 10:27:55 +0000},
	Doi = {10.1145/800055.802028},
	Isbn = {0-89791-142-3},
	Location = {Austin, Texas, USA},
	Pages = {123--128},
	Posted-At = {2014-03-27 10:27:07},
	Priority = {2},
	Publisher = {ACM},
	Series = {LFP '84},
	Title = {{DIALISP} - a {LISP} Machine},
	Url = {http://dx.doi.org/10.1145/800055.802028},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMC4uLy4uL3BhcGVyL1N0ZWY4NGEgRElBTElTUCAtIGEgTElTUCBNYWNoaW5lLnBkZtIXCxgZV05TLmRhdGFPEQIOAAAAAAIOAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfU3RlZjg0YSBESUFMSVNQIC0gYSBMI0JENDc5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvUec9Zu4YAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM9ZrXYAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBTdGVmODRhIERJQUxJU1AgLSBhIEwjQkQ0NzkucGRmAAAOAEoAJABTAHQAZQBmADgANABhACAARABJAEEATABJAFMAUAAgAC0AIABhACAATABJAFMAUAAgAE0AYQBjAGgAaQBuAGUALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAFFVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9TdGVmODRhIERJQUxJU1AgLSBhIExJU1AgTWFjaGluZS5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AwQDGAM4C4ALiAucC8gL7AwkDDQMUAx0DIgMvAzIDRANHA0wAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADTg==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/800055.802028}}

@inproceedings{Nels79a,
	Acmid = {806971},
	Address = {New York, NY, USA},
	Author = {Nelson, Philip A.},
	Booktitle = {Proceedings of the 1979 SIGPLAN Symposium on Compiler Construction},
	Date-Added = {2014-03-26 16:58:45 +0000},
	Date-Modified = {2014-03-26 16:58:46 +0000},
	Doi = {10.1145/800229.806971},
	Isbn = {0-89791-002-8},
	Location = {Denver, Colorado, USA},
	Numpages = {6},
	Pages = {208--213},
	Publisher = {ACM},
	Series = {SIGPLAN '79},
	Title = {A Comparison of PASCAL Intermediate Languages},
	Url = {http://doi.acm.org/10.1145/800229.806971},
	Year = {1979},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800229.806971},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/800229.806971}}

@inproceedings{Eugs06a,
	Acmid = {1167485},
	Address = {New York, NY, USA},
	Author = {Eugster, Patrick},
	Booktitle = {Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-oriented Programming Systems, Languages, and Applications},
	Date-Added = {2014-03-26 16:52:27 +0000},
	Date-Modified = {2014-03-26 16:52:29 +0000},
	Doi = {10.1145/1167473.1167485},
	Isbn = {1-59593-348-4},
	Keywords = {Java, future, proxy, transformation},
	Location = {Portland, Oregon, USA},
	Numpages = {14},
	Pages = {139--152},
	Publisher = {ACM},
	Series = {OOPSLA '06},
	Title = {Uniform Proxies for Java},
	Url = {http://doi.acm.org/10.1145/1167473.1167485},
	Year = {2006},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1167473.1167485},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1167473.1167485}}

@webpage{Graal,
	Date-Added = {2014-03-26 08:58:43 +0000},
	Date-Modified = {2014-03-26 08:59:24 +0000},
	Title = {OpenJDK Community. Graal Project},
	Url = {http: http://openjdk.java.net/projects/graal/},
	Year = {2012},
	Bdsk-Url-1 = {http:%20http://openjdk.java.net/projects/graal/}}

@article{Alpe00a,
	Abstract = {Jalape\~{n}o is a virtual machine for Java{\texttrademark} servers written in the Java language. To be able to address the requirements of servers (performance and scalability in particular), Jalape\~{n}o was designed  '' from scratch ''  to be as self-sufficient as possible. Jalape\~{n}o's unique object model and memory layout allows a hardware null-pointer check as well as fast access to array elements, fields, and methods. Run-time services conventionally provided in native code are implemented primarily in Java. Java threads are multiplexed by virtual processors (implemented as operating system threads). A family of concurrent object allocators and parallel type-accurate garbage collectors is supported. Jalape\~{n}o's interoperable compilers enable quasi-preemptive thread switching and precise location of object references. Jalape\~{n}o's dynamic optimizing compiler is designed to obtain high quality code for methods that are observed to be frequently executed or computationally intensive.},
	Author = {Alpern, B. and Attanasio, C. R. and Barton, J. J. and Burke, M. G. and Cheng, P. and Choi, J. D. and Cocchi, A. and Fink, S. J. and Grove, D. and Hind, M. and Hummel, S. F. and Lieber, D. and Litvinov, V. and Mergen, M. F. and Ngo, T. and Russell, J. R. and Sarkar, V. and Serrano, M. J. and Shepherd, J. C. and Smith, S. E. and Sreedhar, V. C. and Srinivasan, H. and Whaley, J.},
	Citeulike-Article-Id = {10085693},
	Citeulike-Linkout-0 = {http://dx.doi.org/10.1147/sj.391.0211},
	Citeulike-Linkout-1 = {http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=5387060},
	Date-Added = {2014-02-12 14:20:58 +0000},
	Date-Modified = {2014-02-12 14:20:58 +0000},
	Doi = {10.1147/sj.391.0211},
	Institution = {IBM Research Division, Thomas J. Watson Research Center, P.O. Box 218, Yorktown Heights, New York 10598, USA},
	Issn = {0018-8670},
	Journal = {IBM Systems Journal},
	Number = {1},
	Pages = {211--238},
	Posted-At = {2011-12-01 10:59:59},
	Priority = {2},
	Publisher = {IBM},
	Read = {1},
	Title = {The {Jalape\~{n}o} virtual machine},
	Url = {http://dx.doi.org/10.1147/sj.391.0211},
	Volume = {39},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QNC4uLy4uL3BhcGVyL0FscGUwMGEgVGhlIEphbGFwZW5vIHZpcnR1YWwgbWFjaGluZS5wZGbSFwsYGVdOUy5kYXRhTxECGgAAAAACGgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0FscGUwMGEgVGhlIEphbGFwZW5vICNCQ0Y4MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALz4HLeqAOAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADLepH+AAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAQWxwZTAwYSBUaGUgSmFsYXBlbm8gI0JDRjgxLnBkZgAADgBSACgAQQBsAHAAZQAwADAAYQAgAFQAaABlACAASgBhAGwAYQBwAGUAbgBvACAAdgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAFVVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9BbHBlMDBhIFRoZSBKYWxhcGVubyB2aXJ0dWFsIG1hY2hpbmUucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAMUAygDSAvAC8gL3AwIDCwMZAx0DJAMtAzIDPwNCA1QDVwNcAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA14=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1147/sj.391.0211}}

@article{Geof10a,
	Abstract = {Managed Runtime Environments ({MREs}), such as the {JVM} and the {CLI}, form an attractive environment for program execution, by providing portability and safety, via the use of a bytecode language and automatic memory management, as well as good performance, via just-in-time ({JIT}) compilation. Nevertheless, developing a fully featured {MRE}, including e.g. a garbage collector and {JIT} compiler, is a herculean task. As a result, new languages cannot easily take advantage of the benefits of {MREs}, and it is difficult to experiment with extensions of existing {MRE} based languages. This paper describes and evaluates {VMKit}, a first attempt to build a common substrate that eases the development of high-level {MREs}. We have successfully used {VMKit} to build two {MREs}: a Java Virtual Machine and a Common Language Runtime. We provide an extensive study of the lessons learned in developing this infrastructure, and assess the ease of implementing new {MREs} or {MRE} extensions and the resulting performance. In particular, it took one of the authors only one month to develop a Common Language Runtime using {VMKit}. {VMKit} furthermore has performance comparableto the well established open source {MREs} Cacao, Apache Harmony and Mono, and is 1.2 to 3 times slower than {JikesRVM} on most of the Dacapo benchmarks.},
	Address = {New York, NY, USA},
	Annote = {itself the paper is quite nice to read. 
not much detailed information and mainly focusing on engineering efforts I think. 
But they might deliver good background for justifying mate. 
However I think we will differ in the sense that we keep the Smalltalk spirit alive and allow a programmer to modify the running system, and even the VM!},
	Author = {Geoffray, Nicolas and Thomas, Ga\"{e}l and Lawall, Julia and Muller, Gilles and Folliot, Bertil},
	Booktitle = {VEE '10: Proceedings of the 6th ACM SIGPLAN/SIGOPS international conference on Virtual execution environments},
	Citeulike-Article-Id = {7083763},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1735997.1736006},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1735997.1736006},
	Date-Added = {2014-02-12 14:06:19 +0000},
	Date-Modified = {2014-02-12 14:06:19 +0000},
	Doi = {10.1145/1735997.1736006},
	Isbn = {978-1-60558-910-7},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Location = {Pittsburgh, Pennsylvania, USA},
	Month = mar,
	Pages = {51--62},
	Posted-At = {2012-02-20 16:55:34},
	Priority = {2},
	Publisher = {ACM},
	Read = {1},
	Title = {{VMKit}: a substrate for managed runtime environments},
	Url = {http://dx.doi.org/10.1145/1735997.1736006},
	Volume = {45},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSi4uLy4uL3BhcGVyL0dlb2YxMGEgVk1LaXQgYSBzdWJzdHJhdGUgZm9yIG1hbmFnZWQgcnVudGltZSBlbnZpcm9ubWVudHMucGRm0hcLGBlXTlMuZGF0YU8RAlwAAAAAAlwAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9HZW9mMTBhIFZNS2l0IGEgc3Vic3QjQkQwODEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9CBy2cdWAAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAy2cPSAAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AEdlb2YxMGEgVk1LaXQgYSBzdWJzdCNCRDA4MS5wZGYAAA4AfgA+AEcAZQBvAGYAMQAwAGEAIABWAE0ASwBpAHQAIABhACAAcwB1AGIAcwB0AHIAYQB0AGUAIABmAG8AcgAgAG0AYQBuAGEAZwBlAGQAIAByAHUAbgB0AGkAbQBlACAAZQBuAHYAaQByAG8AbgBtAGUAbgB0AHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGtVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9HZW9mMTBhIFZNS2l0IGEgc3Vic3RyYXRlIGZvciBtYW5hZ2VkIHJ1bnRpbWUgZW52aXJvbm1lbnRzLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDbAOAA6ANIA0oDTwNaA2MDcQN1A3wDhQOKA5cDmgOsA68DtAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAO2},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1735997.1736006}}

@article{Cytr91a,
	Abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article.  ACM has opted to expose the complete List rather than only correct and linked references.},
	Address = {New York, NY, USA},
	Author = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
	Citeulike-Article-Id = {244437},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=115320},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/115372.115320},
	Date-Added = {2014-01-29 14:42:33 +0000},
	Date-Modified = {2014-01-29 14:42:33 +0000},
	Doi = {10.1145/115372.115320},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Month = {October},
	Number = {4},
	Pages = {451--490},
	Posted-At = {2010-01-13 17:04:05},
	Priority = {2},
	Publisher = {ACM},
	Read = {1},
	Title = {Efficiently computing static single assignment form and the control dependence graph},
	Url = {http://dx.doi.org/10.1145/115372.115320},
	Volume = {13},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QbC4uLy4uL3BhcGVyL0N5dHI5MWEgRWZmaWNpZW50bHkgY29tcHV0aW5nIHN0YXRpYyBzaW5nbGUgYXNzaWdubWVudCBmb3JtIGFuZCB0aGUgY29udHJvbCBkZXBlbmRlbmNlIGdyYXBoLnBkZtIXCxgZV05TLmRhdGFPEQLCAAAAAALCAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQ3l0cjkxYSBFZmZpY2llbnRseSBjI0JEMDQ3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQR8iNsS8AAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMiNlQ8AAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBDeXRyOTFhIEVmZmljaWVudGx5IGMjQkQwNDcucGRmAAAOAMIAYABDAHkAdAByADkAMQBhACAARQBmAGYAaQBjAGkAZQBuAHQAbAB5ACAAYwBvAG0AcAB1AHQAaQBuAGcAIABzAHQAYQB0AGkAYwAgAHMAaQBuAGcAbABlACAAYQBzAHMAaQBnAG4AbQBlAG4AdAAgAGYAbwByAG0AIABhAG4AZAAgAHQAaABlACAAYwBvAG4AdAByAG8AbAAgAGQAZQBwAGUAbgBkAGUAbgBjAGUAIABnAHIAYQBwAGgALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAI1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DeXRyOTFhIEVmZmljaWVudGx5IGNvbXB1dGluZyBzdGF0aWMgc2luZ2xlIGFzc2lnbm1lbnQgZm9ybSBhbmQgdGhlIGNvbnRyb2wgZGVwZW5kZW5jZSBncmFwaC5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A/QECAQoD0APSA9cD4gPrA/kD/QQEBA0EEgQfBCIENAQ3BDwAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAEPg==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/115372.115320}}

@inproceedings{Clic05a,
	Abstract = {Modern transactional response-time sensitive applications have run into practical limits on the size of garbage collected heaps. The heap can only grow until {GC} pauses exceed the response-time limits. Sustainable, scalable concurrent collection has become a feature worth paying {for.Azul} Systems has built a custom system ({CPU}, chip, board, and {OS}) specifically to run garbage collected virtual machines. The custom {CPU} includes a read barrier instruction. The read barrier enables a highly concurrent (no stop-the-world phases), parallel and compacting {GC} algorithm. The Pauseless algorithm is designed for uninterrupted application execution and consistent mutator throughput in every {GC} {phase.Beyond} the basic requirement of collecting faster than the allocation rate, the Pauseless collector is never in a "rush" to complete any {GC} phase. No phase places an undue burden on the mutators nor do phases race to complete before the mutators produce more work. Portions of the Pauseless algorithm also feature a "self-healing" behavior which limits mutator overhead and reduces mutator sensitivity to the current {GC} {state.We} present the Pauseless {GC} algorithm, the supporting hardware features that enable it, and data on the overhead, efficiency, and pause times when running a sustained workload.},
	Address = {New York, NY, USA},
	Author = {Click, Cliff and Tene, Gil and Wolf, Michael},
	Booktitle = {Proceedings of the 1st ACM/USENIX international conference on Virtual execution environments},
	Citeulike-Article-Id = {3329161},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1064988},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1064979.1064988},
	Date-Added = {2014-01-27 14:26:45 +0000},
	Date-Modified = {2014-01-27 14:26:45 +0000},
	Doi = {10.1145/1064979.1064988},
	Isbn = {1-59593-047-7},
	Location = {Chicago, IL, USA},
	Pages = {46--56},
	Posted-At = {2012-06-01 10:00:39},
	Priority = {2},
	Publisher = {ACM},
	Series = {VEE '05},
	Title = {The pauseless {GC} algorithm},
	Url = {http://dx.doi.org/10.1145/1064979.1064988},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMi4uLy4uL3BhcGVyL0NsaWMwNWEgVGhlIHBhdXNlbGVzcyBHQyBhbGdvcml0aG0ucGRm0hcLGBlXTlMuZGF0YU8RAhQAAAAAAhQAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9DbGljMDVhIFRoZSBwYXVzZWxlc3MjQkQwMTMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9ATy+5RUAAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAy+41MAAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AENsaWMwNWEgVGhlIHBhdXNlbGVzcyNCRDAxMy5wZGYAAA4ATgAmAEMAbABpAGMAMAA1AGEAIABUAGgAZQAgAHAAYQB1AHMAZQBsAGUAcwBzACAARwBDACAAYQBsAGcAbwByAGkAdABoAG0ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAFNVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DbGljMDVhIFRoZSBwYXVzZWxlc3MgR0MgYWxnb3JpdGhtLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDDAMgA0ALoAuoC7wL6AwMDEQMVAxwDJQMqAzcDOgNMA08DVAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANW},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1064979.1064988}}

@inproceedings{Kicz01a,
	Abstract = {{AspectJ\^{A}}¿ is a simple and practical aspect-oriented extension to Java\^{A}¿. With just a few new constructs, {AspectJ} provides support for modular implementation of a range of crosscutting concerns. In {AspectJ}'s dynamic join point model, join points are well-defined points in the execution of the program; pointcuts are collections of join points; advice are special method-like constructs that can be attached to pointcuts; and aspects are modular units of crosscutting implementation, comprising pointcuts, advice, and ordinary Java member declarations. {AspectJ} code is compiled into standard Java bytecode. Simple extensions to existing Java development environments make it possible to browse the crosscutting structure of aspects in the same kind of way as one browses the inheritance structure of classes. Several examples show that {AspectJ} is powerful, and that programs written using it are easy to understand.},
	Address = {London, UK, UK},
	Author = {Kiczales, Gregor and Hilsdale, Erik and Hugunin, Jim and Kersten, Mik and Palm, Jeffrey and Griswold, William G.},
	Booktitle = {Proceedings of the 15th European Conference on Object-Oriented Programming},
	Citeulike-Article-Id = {1272799},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=680006},
	Date-Added = {2014-01-22 16:46:23 +0000},
	Date-Modified = {2014-01-22 16:46:23 +0000},
	Isbn = {3-540-42206-4},
	Pages = {327--353},
	Posted-At = {2014-01-22 16:45:49},
	Priority = {2},
	Publisher = {Springer-Verlag},
	Series = {ECOOP '01},
	Title = {An Overview of {AspectJ}},
	Url = {http://portal.acm.org/citation.cfm?id=680006},
	Year = {2001},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLi4uLy4uL3BhcGVyL0tpY3owMWEgQW4gT3ZlcnZpZXcgb2YgQXNwZWN0Si5wZGbSFwsYGVdOUy5kYXRhTxECCAAAAAACCAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0tpY3owMWEgQW4gT3ZlcnZpZXcgbyNCRDBGQi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0PvPBbRcAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADPBaZMAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAS2ljejAxYSBBbiBPdmVydmlldyBvI0JEMEZCLnBkZgAADgBGACIASwBpAGMAegAwADEAYQAgAEEAbgAgAE8AdgBlAHIAdgBpAGUAdwAgAG8AZgAgAEEAcwBwAGUAYwB0AEoALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAE9Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9LaWN6MDFhIEFuIE92ZXJ2aWV3IG9mIEFzcGVjdEoucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAL8AxADMAtgC2gLfAuoC8wMBAwUDDAMVAxoDJwMqAzwDPwNEAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0Y=},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=680006}}

@inproceedings{Tant03a,
	Abstract = {Behavioral reflection is a powerful approach for adapting the behavior of running applications. In this paper we present and motivate partial behavioral reflection, an approach to more efficient and flexible behavioral reflection. We expose the spatial and temporal dimensions of such reflection, and propose a model of partial behavioral reflection based on the notion of hooksets. In the context of Java, we describe a reflective architecture offering appropriate interfaces for static and dynamic configuration of partial behavioral reflection at various levels, as well as Reflex, an open reflective extension for Java implementing this architecture. Reflex is the first extension that fully supports partial behavioral reflection in a portable manner, and that seamlessly integrates load-time and runtime behavioral reflection. The paper shows preliminary benchmarks and examples supporting the approach. The examples, dealing with the observer pattern and asynchronous communication via transparent futures, also show the interest of partial behavioral reflection as a tool for open dynamic {Aspect-Oriented} Programming.},
	Address = {New York, NY, USA},
	Author = {Tanter, \'{E}ric and Noy{\'{e}}, Jacques and Caromel, Denis and Cointe, Pierre},
	Booktitle = {Proceedings of the 18th Annual ACM SIGPLAN Conference on Object-oriented Programing, Systems, Languages, and Applications},
	Citeulike-Article-Id = {265920},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=949309},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/949305.949309},
	Date-Added = {2014-01-22 16:19:46 +0000},
	Date-Modified = {2014-01-22 16:19:46 +0000},
	Doi = {10.1145/949305.949309},
	Isbn = {1-58113-712-5},
	Location = {Anaheim, California, USA},
	Month = nov,
	Number = {11},
	Pages = {27--46},
	Posted-At = {2014-01-22 16:19:19},
	Priority = {2},
	Publisher = {ACM},
	Series = {OOPSLA '03},
	Title = {Partial Behavioral Reflection: Spatial and Temporal Selection of Reification},
	Url = {http://dx.doi.org/10.1145/949305.949309},
	Volume = {38},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QYy4uLy4uL3BhcGVyL1RhbnQwM2EgUGFydGlhbCBCZWhhdmlvcmFsIFJlZmxlY3Rpb24gU3BhdGlhbCBhbmQgVGVtcG9yYWwgU2VsZWN0aW9uIG9mIFJlaWZpY2F0aW9uLnBkZtIXCxgZV05TLmRhdGFPEQKmAAAAAAKmAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfVGFudDAzYSBQYXJ0aWFsIEJlaGF2I0JENDg3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvUh88FricAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM8FoBcAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBUYW50MDNhIFBhcnRpYWwgQmVoYXYjQkQ0ODcucGRmAAAOALAAVwBUAGEAbgB0ADAAMwBhACAAUABhAHIAdABpAGEAbAAgAEIAZQBoAGEAdgBpAG8AcgBhAGwAIABSAGUAZgBsAGUAYwB0AGkAbwBuACAAUwBwAGEAdABpAGEAbAAgAGEAbgBkACAAVABlAG0AcABvAHIAYQBsACAAUwBlAGwAZQBjAHQAaQBvAG4AIABvAGYAIABSAGUAaQBmAGkAYwBhAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAIRVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9UYW50MDNhIFBhcnRpYWwgQmVoYXZpb3JhbCBSZWZsZWN0aW9uIFNwYXRpYWwgYW5kIFRlbXBvcmFsIFNlbGVjdGlvbiBvZiBSZWlmaWNhdGlvbi5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgD0APkBAQOrA60DsgO9A8YD1APYA98D6APtA/oD/QQPBBIEFwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQZ},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/949305.949309}}

@inproceedings{Lin12b,
	Abstract = {Program portability is an important software engineering consideration. However, when high-level languages are extended to effectively implement system projects for software engineering gain and safety, portability is compromised--high-level code for low-level programming cannot execute on a stock runtime, and, conversely, a runtime with special support implemented will not be portable across different platforms. We explore the portability pitfall of high-level low-level programming in the context of virtual machine implementation tasks. Our approach is designing a restricted high-level language called {RJava}, with a flexible restriction model and effective low-level extensions, which is suitable for different scopes of virtual machine implementation, and also suitable for a low-level language bypass for improved portability. Apart from designing such a language, another major outcome from this work is clearing up and sharpening the philosophy around language restriction in virtual machine design. In combination, our approach to solving portability pitfalls with {RJava} favors virtual machine design and implementation in terms of portability and robustness.},
	Address = {New York, NY, USA},
	Author = {Lin, Yi and Blackburn, Stephen M.},
	Booktitle = {Proceedings of the Sixth ACM Workshop on Virtual Machines and Intermediate Languages},
	Citeulike-Article-Id = {12933161},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2414740.2414746},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2414740.2414746},
	Date-Added = {2014-01-21 17:14:54 +0000},
	Date-Modified = {2014-01-21 17:14:54 +0000},
	Doi = {10.1145/2414740.2414746},
	Isbn = {978-1-4503-1633-0},
	Location = {Tucson, Arizona, USA},
	Pages = {23--32},
	Posted-At = {2014-01-21 17:12:40},
	Priority = {2},
	Publisher = {ACM},
	Series = {VMIL '12},
	Title = {Bypassing Portability Pitfalls of High-level Low-level Programming},
	Url = {http://dx.doi.org/10.1145/2414740.2414746},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QWS4uLy4uL3BhcGVyL0xpbjEyYiBCeXBhc3NpbmcgUG9ydGFiaWxpdHkgUGl0ZmFsbHMgb2YgSGlnaC1sZXZlbCBMb3ctbGV2ZWwgUHJvZ3JhbW1pbmcucGRm0hcLGBlXTlMuZGF0YU8RAogAAAAAAogAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9MaW4xMmIgQnlwYXNzaW5nIFBvcnQjQkQxMTkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9EZzwRpKwAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzwRbGwAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AExpbjEyYiBCeXBhc3NpbmcgUG9ydCNCRDExOS5wZGYAAA4AnABNAEwAaQBuADEAMgBiACAAQgB5AHAAYQBzAHMAaQBuAGcAIABQAG8AcgB0AGEAYgBpAGwAaQB0AHkAIABQAGkAdABmAGEAbABsAHMAIABvAGYAIABIAGkAZwBoAC0AbABlAHYAZQBsACAATABvAHcALQBsAGUAdgBlAGwAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHpVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9MaW4xMmIgQnlwYXNzaW5nIFBvcnRhYmlsaXR5IFBpdGZhbGxzIG9mIEhpZ2gtbGV2ZWwgTG93LWxldmVsIFByb2dyYW1taW5nLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAOoA7wD3A4MDhQOKA5UDngOsA7ADtwPAA8UD0gPVA+cD6gPvAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA/E=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2414740.2414746}}

@inproceedings{Wimm12a,
	Abstract = {Modularity is a key concept for large and complex applications and an important enabler for collaborative research. In comparison, virtual machines ({VMs}) are still mostly monolithic pieces of software. Our goal is to significantly reduce to the cost of extending {VMs} to efficiently host and execute multiple, dynamic languages. We are designing and implementing a {VM} following the "everything is extensible" paradigm. Among the novel use cases that will be enabled by our research are: {VM} extensions by third parties, support for multiple languages inside one {VM}, and a universal {VM} for mobile devices. Our research will be based on the existing state of the art. We will reuse an existing metacircular Java {VM} and an existing dynamic language {VM} implemented in Java. We will split the {VMs} into fine-grained modules, define explicit interfaces and extension points for the modules, and finally re-connect them. Performance is one of the most important concerns for {VMs}. Modularity improves flexibility but can introduce an unacceptable performance overhead at the module boundaries, e.g., for inter-module method calls. We will identify this overhead and address it with novel feedback-directed compiler optimizations. These optimizations will also improve the performance of modular applications running on top of our {VM}. The expected results of our research will be not only new insights and a new design approach for {VMs}, but also a complete reference implementation of a modular {VM} where everything is extensible by third parties and that supports multiple languages.},
	Address = {New York, NY, USA},
	Author = {Wimmer, Christian and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
	Booktitle = {Proceedings of the 11th Annual International Conference on Aspect-oriented Software Development},
	Citeulike-Article-Id = {12933153},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2162049.2162073},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2162049.2162073},
	Date-Added = {2014-01-21 17:09:23 +0000},
	Date-Modified = {2014-01-21 17:09:23 +0000},
	Doi = {10.1145/2162049.2162073},
	Isbn = {978-1-4503-1092-5},
	Location = {Potsdam, Germany},
	Pages = {203--214},
	Posted-At = {2014-01-21 17:08:59},
	Priority = {2},
	Publisher = {ACM},
	Series = {AOSD '12},
	Title = {Fine-grained Modularity and Reuse of Virtual Machine Components},
	Url = {http://dx.doi.org/10.1145/2162049.2162073},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QVy4uLy4uL3BhcGVyL1dpbW0xMmEgRmluZS1ncmFpbmVkIE1vZHVsYXJpdHkgYW5kIFJldXNlIG9mIFZpcnR1YWwgTWFjaGluZSBDb21wb25lbnRzLnBkZtIXCxgZV05TLmRhdGFPEQKCAAAAAAKCAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfV2ltbTEyYSBGaW5lLWdyYWluZWQgI0JENEQzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvU088EaC8AAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM8EWh8AAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBXaW1tMTJhIEZpbmUtZ3JhaW5lZCAjQkQ0RDMucGRmAAAOAJgASwBXAGkAbQBtADEAMgBhACAARgBpAG4AZQAtAGcAcgBhAGkAbgBlAGQAIABNAG8AZAB1AGwAYQByAGkAdAB5ACAAYQBuAGQAIABSAGUAdQBzAGUAIABvAGYAIABWAGkAcgB0AHUAYQBsACAATQBhAGMAaABpAG4AZQAgAEMAbwBtAHAAbwBuAGUAbgB0AHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHhVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9XaW1tMTJhIEZpbmUtZ3JhaW5lZCBNb2R1bGFyaXR5IGFuZCBSZXVzZSBvZiBWaXJ0dWFsIE1hY2hpbmUgQ29tcG9uZW50cy5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDoAO0A9QN7A30DggONA5YDpAOoA68DuAO9A8oDzQPfA+ID5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPp},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2162049.2162073}}

@inproceedings{Chib96a,
	Abstract = {An abstract is not available.},
	Address = {London, UK, UK},
	Author = {Chiba, Shigeru and Kiczales, Gregor and Lamping, John},
	Booktitle = {Proceedings of the Second JSSST International Symposium on Object Technologies for Advanced Software},
	Citeulike-Article-Id = {12620007},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=646898.756984},
	Date-Added = {2014-01-21 16:59:43 +0000},
	Date-Modified = {2014-01-21 16:59:43 +0000},
	Isbn = {3-540-60954-7},
	Pages = {157--172},
	Posted-At = {2013-09-13 16:37:02},
	Priority = {2},
	Publisher = {Springer-Verlag},
	Series = {ISOTAS '96},
	Title = {Avoiding Confusion in Metacircularity: The {Meta-Helix}},
	Url = {http://portal.acm.org/citation.cfm?id=646898.756984},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QTC4uLy4uL3BhcGVyL0NoaWI5NmEgQXZvaWRpbmcgQ29uZnVzaW9uIGluIE1ldGFjaXJjdWxhcml0eSBUaGUgTWV0YS1IZWxpeC5wZGbSFwsYGVdOUy5kYXRhTxECYgAAAAACYgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0NoaWI5NmEgQXZvaWRpbmcgQ29uZiNCRDAwNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0AfOWP25AAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADOWOGZAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAQ2hpYjk2YSBBdm9pZGluZyBDb25mI0JEMDA3LnBkZgAADgCCAEAAQwBoAGkAYgA5ADYAYQAgAEEAdgBvAGkAZABpAG4AZwAgAEMAbwBuAGYAdQBzAGkAbwBuACAAaQBuACAATQBlAHQAYQBjAGkAcgBjAHUAbABhAHIAaQB0AHkAIABUAGgAZQAgAE0AZQB0AGEALQBIAGUAbABpAHgALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAG1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DaGliOTZhIEF2b2lkaW5nIENvbmZ1c2lvbiBpbiBNZXRhY2lyY3VsYXJpdHkgVGhlIE1ldGEtSGVsaXgucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAN0A4gDqA1ADUgNXA2IDawN5A30DhAONA5IDnwOiA7QDtwO8AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA74=},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=646898.756984}}

@inproceedings{Assa08a,
	Abstract = {This paper considers the difficulties linked to the static scheduling strategy of {AspectJ} and shows how to overcome them by turning to a more dynamic strategy, making it possible to order, cancel, and deploy aspects at runtime. We show that this more dynamic strategy can be obtained by a minor update of the semantics of {AspectJ} introducing the notion of current aspect group, that is, the aspects scheduled for the current join point. We show how to reflect this change at the language level and present a prototype of the resulting {AspectJ} variant, Dynamic {AspectJ}. This prototype reuses {AspectJ} to perform a first step of static weaving, which we complement by a second step of dynamic weaving, implemented through a thin interpretation layer. This can be seen as an interesting example of reconciling interpreters and compilers, the dynamic and the static world.},
	Address = {New York, NY, USA},
	Author = {Assaf, Ali and Noy{\'{e}}, Jacques},
	Booktitle = {Proceedings of the 2008 Symposium on Dynamic Languages},
	Citeulike-Article-Id = {6414710},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1408681.1408689},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1408681.1408689},
	Date-Added = {2014-01-21 16:57:22 +0000},
	Date-Modified = {2014-01-21 16:57:22 +0000},
	Doi = {10.1145/1408681.1408689},
	Isbn = {978-1-60558-270-2},
	Location = {Paphos, Cyprus},
	Pages = {1--12},
	Posted-At = {2014-01-21 16:54:30},
	Priority = {2},
	Publisher = {ACM},
	Series = {DLS '08},
	Title = {Dynamic {AspectJ}},
	Url = {http://dx.doi.org/10.1145/1408681.1408689},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJy4uLy4uL3BhcGVyL0Fzc2EwOGEgRHluYW1pYyBBc3BlY3RKLnBkZtIXCxgZV05TLmRhdGFPEQHuAAAAAAHuAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsbQXNzYTA4YSBEeW5hbWljIEFzcGVjdEoucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvPjs8EZXkAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM8EV2kAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAF1TYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBBc3NhMDhhIER5bmFtaWMgQXNwZWN0Si5wZGYAAA4AOAAbAEEAcwBzAGEAMAA4AGEAIABEAHkAbgBhAG0AaQBjACAAQQBzAHAAZQBjAHQASgAuAHAAZABmAA8AIAAPAFMAYQBtAHMAdQBuAGcAIABTAFMARAAgADgANAAwABIASFVzZXJzL2NhbWlsbG9icnVuaS9Eb2N1bWVudHMvZWR1Y2F0aW9uL3BhcGVyL0Fzc2EwOGEgRHluYW1pYyBBc3BlY3RKLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALgAvQDFArcCuQK+AskC0gLgAuQC6wL0AvkDBgMJAxsDHgMjAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAyU=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1408681.1408689}}

@inproceedings{Wimm10a,
	Abstract = {The linear scan algorithm for register allocation provides a good register assignment with a low compilation overhead and is thus frequently used for just-in-time compilers. Although most of these compilers use static single assignment ({SSA}) form, the algorithm has not yet been applied on {SSA} form, i.e., {SSA} form is usually deconstructed before register allocation. However, the structural properties of {SSA} form can be used to simplify the algorithm. With only one definition per variable, lifetime intervals (the main data structure) can be constructed without data flow analysis. During allocation, some tests of interval intersection can be skipped because {SSA} form guarantees non-intersection. Finally, deconstruction of {SSA} form after register allocation can be integrated into the resolution phase of the register allocator without much additional code. We modified the linear scan register allocator of the Java {HotSpot} client compiler so that it operates on {SSA} form. The evaluation shows that our simpler and faster version generates equally good or slightly better machine code.},
	Address = {New York, NY, USA},
	Author = {Wimmer, Christian and Franz, Michael},
	Booktitle = {Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
	Citeulike-Article-Id = {7097611},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1772954.1772979},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1772954.1772979},
	Date-Added = {2014-01-21 16:41:46 +0000},
	Date-Modified = {2014-01-21 16:41:46 +0000},
	Doi = {10.1145/1772954.1772979},
	Isbn = {978-1-60558-635-9},
	Location = {Toronto, Ontario, Canada},
	Pages = {170--179},
	Posted-At = {2014-01-21 16:41:07},
	Priority = {2},
	Publisher = {ACM},
	Series = {CGO '10},
	Title = {Linear Scan Register Allocation on {SSA} Form},
	Url = {http://dx.doi.org/10.1145/1772954.1772979},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QQy4uLy4uL3BhcGVyL1dpbW0xMGEgTGluZWFyIFNjYW4gUmVnaXN0ZXIgQWxsb2NhdGlvbiBvbiBTU0EgRm9ybS5wZGbSFwsYGVdOUy5kYXRhTxECRgAAAAACRgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1dpbW0xMGEgTGluZWFyIFNjYW4gUiNCRDREMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL1NHPBGGdAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADPBFONAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAV2ltbTEwYSBMaW5lYXIgU2NhbiBSI0JENEQxLnBkZgAADgBwADcAVwBpAG0AbQAxADAAYQAgAEwAaQBuAGUAYQByACAAUwBjAGEAbgAgAFIAZQBnAGkAcwB0AGUAcgAgAEEAbABsAG8AYwBhAHQAaQBvAG4AIABvAG4AIABTAFMAQQAgAEYAbwByAG0ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGRVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9XaW1tMTBhIExpbmVhciBTY2FuIFJlZ2lzdGVyIEFsbG9jYXRpb24gb24gU1NBIEZvcm0ucGRmABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A1ADZAOEDKwMtAzIDPQNGA1QDWANfA2gDbQN6A30DjwOSA5cAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADmQ==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1772954.1772979}}

@inproceedings{Chis13a,
	Abstract = {The debugger is an essential tool in any programming environment, as it helps developers understand the dynamic behaviour of software systems. However, traditional debuggers fail in answering domain-specific questions, as the semantics of what they show and do are fixed. In this paper we introduce our work towards a moldable debugger which, unlike traditional debuggers, both adapts itself and can be adapted to a particular debugging context. Thus, it allows developers to answer their questions by using concepts from their own application domains.},
	Address = {New York, NY, USA},
	Author = {Chi\c{s}, Andrei and Nierstrasz, Oscar and G\^{i}rba, Tudor},
	Booktitle = {Proceedings of the 7th Workshop on Dynamic Languages and Applications},
	Citeulike-Article-Id = {12933109},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2489798.2489801},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2489798.2489801},
	Date-Added = {2014-01-21 16:33:23 +0000},
	Date-Modified = {2014-01-21 16:49:52 +0000},
	Doi = {10.1145/2489798.2489801},
	Isbn = {978-1-4503-2041-2},
	Location = {Montpellier, France},
	Posted-At = {2014-01-21 16:32:06},
	Priority = {2},
	Publisher = {ACM},
	Series = {DYLA '13},
	Title = {Towards a Moldable Debugger},
	Url = {http://dx.doi.org/10.1145/2489798.2489801},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMy4uLy4uL3BhcGVyL0NoaXMxM2EgVG93YXJkcyBhIE1vbGRhYmxlIERlYnVnZ2VyLnBkZtIXCxgZV05TLmRhdGFPEQIWAAAAAAIWAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQ2hpczEzYSBUb3dhcmRzIGEgTW9sI0JEMDA5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQCc8EX9cAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM8EUccAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBDaGlzMTNhIFRvd2FyZHMgYSBNb2wjQkQwMDkucGRmAAAOAFAAJwBDAGgAaQBzADEAMwBhACAAVABvAHcAYQByAGQAcwAgAGEAIABNAG8AbABkAGEAYgBsAGUAIABEAGUAYgB1AGcAZwBlAHIALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAFRVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DaGlzMTNhIFRvd2FyZHMgYSBNb2xkYWJsZSBEZWJ1Z2dlci5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDEAMkA0QLrAu0C8gL9AwYDFAMYAx8DKAMtAzoDPQNPA1IDVwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANZ},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2489798.2489801}}

@article{Denk06a,
	Abstract = {Transforming programs to alter their semantics is of wide interest, for purposes as diverse as off-the-shelf component adaptation, optimization, trace generation, and experimentation with new language features. The current wave of interest in advanced technologies for better separation of concerns, such as aspect-oriented programming, is a solid testimony of this fact. Strangely enough, almost all proposals are formulated in the context of Java, in which tool providers encounter severe restrictions due to the rigidity of the environment. This paper presents BYTESURGEON, a library to transform binary code in Smalltalk. BYTESURGEON takes full advantage of the flexibility of the Squeak environment to enable bytecode transformation at runtime, thereby allowing dynamic, on-the-fly modification of applications. BYTESURGEON operates on bytecode in order to cope with situations where the source code is not available, while providing appropriate high-level abstractions so that users do not need to program at the bytecode level. We illustrate the use of BYTESURGEON via the implementation of method wrappers and a simple MOP, and report on its efficiency.},
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Denker, Marcus and Ducasse, St\'{e}phane and Tanter, \'{E}ric},
	Citeulike-Article-Id = {7676752},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1646593.1646614},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1016/j.cl.2005.10.002},
	Date-Added = {2014-01-21 16:31:11 +0000},
	Date-Modified = {2014-01-21 16:31:11 +0000},
	Doi = {10.1016/j.cl.2005.10.002},
	Issn = {1477-8424},
	Journal = {Comput. Lang. Syst. Struct.},
	Number = {2-3},
	Pages = {125--139},
	Posted-At = {2010-08-18 10:28:33},
	Priority = {2},
	Publisher = {Elsevier Science Publishers B. V.},
	Title = {Runtime bytecode transformation for {Smalltalk}},
	Url = {http://dx.doi.org/10.1016/j.cl.2005.10.002},
	Volume = {32},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRS4uLy4uL3BhcGVyL0RlbmswNmEgUnVudGltZSBieXRlY29kZSB0cmFuc2Zvcm1hdGlvbiBmb3IgU21hbGx0YWxrLnBkZtIXCxgZV05TLmRhdGFPEQJMAAAAAAJMAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfRGVuazA2YSBSdW50aW1lIGJ5dGVjI0JEMDRBLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQSsiRdJ4AAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMiRWH4AAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBEZW5rMDZhIFJ1bnRpbWUgYnl0ZWMjQkQwNEEucGRmAAAOAHQAOQBEAGUAbgBrADAANgBhACAAUgB1AG4AdABpAG0AZQAgAGIAeQB0AGUAYwBvAGQAZQAgAHQAcgBhAG4AcwBmAG8AcgBtAGEAdABpAG8AbgAgAGYAbwByACAAUwBtAGEAbABsAHQAYQBsAGsALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGZVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9EZW5rMDZhIFJ1bnRpbWUgYnl0ZWNvZGUgdHJhbnNmb3JtYXRpb24gZm9yIFNtYWxsdGFsay5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDWANsA4wMzAzUDOgNFA04DXANgA2cDcAN1A4IDhQOXA5oDnwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOh},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/j.cl.2005.10.002}}

@inproceedings{Wern12a,
	Abstract = {Highly available software systems occasionally need to be updated while avoiding downtime. Dynamic software updates reduce downtime, but still require the system to reach a quiescent state in which a global update can be performed. This can be difficult for multi-threaded systems. We present a novel approach to dynamic updates using first-class contexts, called Theseus. First-class contexts make global updates unnecessary: existing threads run to termination in an old context, while new threads start in a new, updated context; consistency between contexts is ensured with the help of bidirectional transformations. We show how first-class contexts offer a practical and flexible approach to incremental dynamic updates, with acceptable overhead.},
	Address = {Berlin, Heidelberg},
	Author = {Wernli, Erwann and Lungu, Mircea and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 50th international conference on Objects, Models, Components, Patterns},
	Citeulike-Article-Id = {12619953},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2366988.2367009},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1007/978-3-642-30561-0\_21},
	Date-Added = {2014-01-21 16:30:56 +0000},
	Date-Modified = {2014-01-21 16:30:56 +0000},
	Doi = {10.1007/978-3-642-30561-0\_21},
	Isbn = {978-3-642-30560-3},
	Location = {Prague, Czech Republic},
	Pages = {304--319},
	Posted-At = {2013-09-13 15:53:25},
	Priority = {2},
	Publisher = {Springer-Verlag},
	Series = {TOOLS'12},
	Title = {Incremental dynamic updates with first-class contexts},
	Url = {http://dx.doi.org/10.1007/978-3-642-30561-0\_21},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QTS4uLy4uL3BhcGVyL1dlcm4xMmEgSW5jcmVtZW50YWwgZHluYW1pYyB1cGRhdGVzIHdpdGggZmlyc3QtY2xhc3MgY29udGV4dHMucGRm0hcLGBlXTlMuZGF0YU8RAmQAAAAAAmQAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9XZXJuMTJhIEluY3JlbWVudGFsIGQjQkQ0RDAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9TQzljzlAAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzljXdAAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFdlcm4xMmEgSW5jcmVtZW50YWwgZCNCRDREMC5wZGYAAA4AhABBAFcAZQByAG4AMQAyAGEAIABJAG4AYwByAGUAbQBlAG4AdABhAGwAIABkAHkAbgBhAG0AaQBjACAAdQBwAGQAYQB0AGUAcwAgAHcAaQB0AGgAIABmAGkAcgBzAHQALQBjAGwAYQBzAHMAIABjAG8AbgB0AGUAeAB0AHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAG5Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9XZXJuMTJhIEluY3JlbWVudGFsIGR5bmFtaWMgdXBkYXRlcyB3aXRoIGZpcnN0LWNsYXNzIGNvbnRleHRzLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAN4A4wDrA1MDVQNaA2UDbgN8A4ADhwOQA5UDogOlA7cDugO/AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA8E=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-642-30561-0%5C_21}}

@inproceedings{Bolz09a,
	Abstract = {We attempt to apply the technique of Tracing JIT Compilers in the context of the PyPy project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing JIT compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing JIT to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing JIT compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two PyPy interpreters: one is a small example, and the other one is the full Python interpreter.},
	Address = {New York, NY, USA},
	Author = {Bolz, Carl F. and Cuni, Antonio and Fijalkowski, Maciej and Rigo, Armin},
	Booktitle = {ICOOOLPS '09: Proceedings of the 4th workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages and Programming Systems},
	Citeulike-Article-Id = {6536700},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1565824.1565827},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1565824.1565827},
	Date-Added = {2014-01-21 16:30:22 +0000},
	Date-Modified = {2014-01-21 16:30:22 +0000},
	Doi = {10.1145/1565824.1565827},
	Isbn = {978-1-60558-541-3},
	Location = {Genova, Italy},
	Pages = {18--25},
	Posted-At = {2010-01-13 16:43:15},
	Priority = {2},
	Publisher = {ACM},
	Read = {1},
	Title = {Tracing the meta-level: {PyPy}'s tracing {JIT} compiler},
	Url = {http://dx.doi.org/10.1145/1565824.1565827},
	Year = {2009},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSi4uLy4uL3BhcGVyL0JvbHowOWEgVHJhY2luZyB0aGUgbWV0YS1sZXZlbCBQeVB5J3MgdHJhY2luZyBKSVQgY29tcGlsZXIucGRm0hcLGBlXTlMuZGF0YU8RAlwAAAAAAlwAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9Cb2x6MDlhIFRyYWNpbmcgdGhlIG0jQkNGQjEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8+xyBTBEAAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAyBSk8AAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AEJvbHowOWEgVHJhY2luZyB0aGUgbSNCQ0ZCMS5wZGYAAA4AfgA+AEIAbwBsAHoAMAA5AGEAIABUAHIAYQBjAGkAbgBnACAAdABoAGUAIABtAGUAdABhAC0AbABlAHYAZQBsACAAUAB5AFAAeQAnAHMAIAB0AHIAYQBjAGkAbgBnACAASgBJAFQAIABjAG8AbQBwAGkAbABlAHIALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGtVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9Cb2x6MDlhIFRyYWNpbmcgdGhlIG1ldGEtbGV2ZWwgUHlQeSdzIHRyYWNpbmcgSklUIGNvbXBpbGVyLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDbAOAA6ANIA0oDTwNaA2MDcQN1A3wDhQOKA5cDmgOsA68DtAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAO2},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1565824.1565827}}

@phdthesis{Denk08b,
	Abstract = {Computational reflection is a fundamental mechanism
                  in object oriented languages. Reflection has proved
                  useful in many contexts, such as in the design of
                  development environments, language extension, and
                  the dynamic, unanticipated adaptation of running
                  systems We identify three problems with the current
                  approach to reflection in object oriented languages:
                  partial behavioral reflection needs to be
                  anticipated, structural reflection is limited to the
                  granularity of a method, and behavioral reflection
                  cannot be applied to the whole system. To address
                  these problems, we extend structural reflection to
                  cover sub-method elements and present how sub-method
                  structural reflection supports unanticipated partial
                  behavioral reflection. We add the concept of context
                  to represent meta-level execution and show how this
                  allows behavioral reflection to be applied even to
                  system classes. We describe an implementation in
                  Smalltalk. Benchmarks validate the practicability of
                  our approach. In addition, we present an
                  experimental evaluation in which we show how the
                  system is used for dynamic analysis. We realize
                  dynamic feature analysis by annotating the
                  sub-method structure of the system directly to
                  denote features instead of recording full execution
                  traces.},
	Author = {Marcus Denker},
	Date-Added = {2014-01-21 16:30:11 +0000},
	Date-Modified = {2014-01-21 16:30:11 +0000},
	Keywords = {scg-phd snf08 jb08 reflectivity},
	Month = may,
	School = {University of Bern},
	Title = {Sub-method Structural and Behavioral Reflection},
	Type = {{PhD} thesis},
	Url = {http://scg.unibe.ch/archive/phd/denker-phd.pdf},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRy4uLy4uL3BhcGVyL0RlbmswOGIgU3ViLW1ldGhvZCBTdHJ1Y3R1cmFsIGFuZCBCZWhhdmlvcmFsIFJlZmxlY3Rpb24ucGRm0hcLGBlXTlMuZGF0YU8RAlIAAAAAAlIAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9EZW5rMDhiIFN1Yi1tZXRob2QgU3QjQkQwNEYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9BPyJSwOwAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAyJSUGwAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AERlbmswOGIgU3ViLW1ldGhvZCBTdCNCRDA0Ri5wZGYAAA4AeAA7AEQAZQBuAGsAMAA4AGIAIABTAHUAYgAtAG0AZQB0AGgAbwBkACAAUwB0AHIAdQBjAHQAdQByAGEAbAAgAGEAbgBkACAAQgBlAGgAYQB2AGkAbwByAGEAbAAgAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGhVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9EZW5rMDhiIFN1Yi1tZXRob2QgU3RydWN0dXJhbCBhbmQgQmVoYXZpb3JhbCBSZWZsZWN0aW9uLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOANgA3QDlAzsDPQNCA00DVgNkA2gDbwN4A30DigONA58DogOnAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6k=},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/phd/denker-phd.pdf}}

@inproceedings{Berg03a,
	Abstract = {Classical module systems support well the modular
                  development of applications but do not offer the
                  ability to add or replace a method in a class that
                  is not defined in that module. On the other hand,
                  languages that support method addition and
                  replacement do not provide a modular view of
                  applications, and their changes have a global
                  impact. The result is a gap between module systems
                  for object-oriented languages on one hand, and the
                  very desirable feature of method addition and
                  replacement on the other hand. To solve these
                  problems we present classboxes, a module system for
                  object-oriented languages that provides method
                  addition and replacement. Moreover, the changes made
                  by a classbox are only visible to that classbox (or
                  classboxes that import it), a feature we call local
                  rebinding. To validate the model, we have
                  implemented it in the Squeak Smalltalk environment,
                  and performed experiments modularising code.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference. Locally rebind methods by rewriting the lookup and take the current classbox context into account},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
	Date-Added = {2014-01-21 16:28:27 +0000},
	Date-Modified = {2014-01-21 16:28:27 +0000},
	Doi = {10.1007/b12023},
	Inria = {hors},
	Isbn = {978-3-540-40796-6},
	Keywords = {snf03 scg-pub jb03 module stefPub classbox alexandrePub alexPub noWorkshop},
	Misc = {Best Paper Award},
	Pages = {122--131},
	Publisher = {Springer-Verlag},
	Read = {1},
	Selectif = {non},
	Series = {LNCS},
	Title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
	Url = {http://www.springerlink.com/index/G5C3J6EB427YCDH2},
	Volume = {2789},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QVC4uLy4uL3BhcGVyL0JlcmcwM2EgQ2xhc3Nib3hlcyBBIE1pbmltYWwgTW9kdWxlIE1vZGVsIFN1cHBvcnRpbmcgTG9jYWwgUmViaW5kaW5nLnBkZtIXCxgZV05TLmRhdGFPEQJ6AAAAAAJ6AAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQmVyZzAzYSBDbGFzc2JveGVzIEEgI0JDRkEwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvPoMqX224AAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMqXv04AAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBCZXJnMDNhIENsYXNzYm94ZXMgQSAjQkNGQTAucGRmAAAOAJIASABCAGUAcgBnADAAMwBhACAAQwBsAGEAcwBzAGIAbwB4AGUAcwAgAEEAIABNAGkAbgBpAG0AYQBsACAATQBvAGQAdQBsAGUAIABNAG8AZABlAGwAIABTAHUAcABwAG8AcgB0AGkAbgBnACAATABvAGMAYQBsACAAUgBlAGIAaQBuAGQAaQBuAGcALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHVVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9CZXJnMDNhIENsYXNzYm94ZXMgQSBNaW5pbWFsIE1vZHVsZSBNb2RlbCBTdXBwb3J0aW5nIExvY2FsIFJlYmluZGluZy5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A5QDqAPIDcANyA3cDggOLA5kDnQOkA60DsgO/A8ID1APXA9wAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD3g==},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf%20http://www.springerlink.com/index/G5C3J6EB427YCDH2},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b12023}}

@inproceedings{Roet07b,
	Abstract = {Dynamic, unanticipated adaptation of running systems
                  is of interest in a variety of situations, ranging
                  from functional upgrades to on-the-fly debugging or
                  monitoring of critical applications. In this paper
                  we study a particular form of computational
                  reflection, called unanticipated partial behavioral
                  reflection, which is particularly well-suited for
                  unanticipated adaptation of real-world systems. Our
                  proposal combines the dynamicity of unanticipated
                  reflection, i.e., reflection that does not require
                  preparation of the code of any sort, and the
                  selectivity and efficiency of partial behavioral
                  reflection. First, we propose unanticipated partial
                  behavioral reflection which enables the developer to
                  precisely select the required reifications, to
                  flexibly engineer the metalevel and to introduce the
                  meta behavior dynamically. Second, we present a
                  system supporting unanticipated partial behavioral
                  reflection in Squeak Smalltalk, called Geppetto, and
                  illustrate its use with a concrete example of a
                  Seaside web application. Benchmarks validate the
                  applicability of our proposal as an extension to the
                  standard reflective abilities of Smalltalk.},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
	Date-Added = {2014-01-21 16:25:49 +0000},
	Date-Modified = {2014-01-21 16:25:49 +0000},
	Doi = {10.1007/978-3-540-71836-9_3},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {scg07 scg-pub jb07 snf06 roethlisberger reflectivity},
	Medium = {2},
	Pages = {47--65},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Unanticipated Partial Behavioral Reflection},
	Url = {http://scg.unibe.ch/archive/papers/Roet07bUPBReflection.pdf},
	Volume = {4406},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QQy4uLy4uL3BhcGVyL1JvZXQwN2IgVW5hbnRpY2lwYXRlZCBQYXJ0aWFsIEJlaGF2aW9yYWwgUmVmbGVjdGlvbi5wZGbSFwsYGVdOUy5kYXRhTxECRgAAAAACRgACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1JvZXQwN2IgVW5hbnRpY2lwYXRlZCNCRDFCOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0bjLRw4iAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADLRwASAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAUm9ldDA3YiBVbmFudGljaXBhdGVkI0JEMUI4LnBkZgAADgBwADcAUgBvAGUAdAAwADcAYgAgAFUAbgBhAG4AdABpAGMAaQBwAGEAdABlAGQAIABQAGEAcgB0AGkAYQBsACAAQgBlAGgAYQB2AGkAbwByAGEAbAAgAFIAZQBmAGwAZQBjAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGRVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9Sb2V0MDdiIFVuYW50aWNpcGF0ZWQgUGFydGlhbCBCZWhhdmlvcmFsIFJlZmxlY3Rpb24ucGRmABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A1ADZAOEDKwMtAzIDPQNGA1QDWANfA2gDbQN6A30DjwOSA5cAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADmQ==},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet07bUPBReflection.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-71836-9_3}}

@inproceedings{Chev11a,
	Acmid = {2047858},
	Address = {New York, NY, USA},
	Author = {Chevalier-Boisvert, Maxime and Lavoie, Erick and Feeley, Marc and Dufour, Bruno},
	Booktitle = {Proceedings of the 7th symposium on Dynamic languages},
	Date-Added = {2014-01-20 16:50:47 +0000},
	Date-Modified = {2014-01-20 16:50:47 +0000},
	Doi = {10.1145/2047849.2047858},
	Isbn = {978-1-4503-0939-4},
	Keywords = {compiler, framework, implementation, javascript, optimization, self-hosted, virtual machine},
	Location = {Portland, Oregon, USA},
	Numpages = {12},
	Pages = {61--72},
	Publisher = {ACM},
	Series = {DLS '11},
	Title = {Bootstrapping a self-hosted research virtual machine for JavaScript: an experience report},
	Url = {http://doi.acm.org/10.1145/2047849.2047858},
	Year = {2011},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2047849.2047858},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2047849.2047858}}

@inproceedings{Cant04a,
	Abstract = {This paper presents {DTrace}, a new facility for dynamic instrumentation of production systems. {DTrace} features the ability to dynamically instrument both user-level and kernel-level software in a unified and absolutely safe fashion. When not explicitly enabled, {DTrace} has zero. probe effect--the system operates exactly as if {DTrace} were not present at all. {DTrace} allows for many tens of thousands of instrumentation points, with even the smallest of systems offering on the order of 30,000 such points in the kernel alone. We have developed a C-like high-level control language to describe the predicates and actions at a given point of instrumentation. The language features user-defined variables, including thread-local variables and associative arrays. To eliminate the need for most postprocessing, the facility features a scalable mechanism for aggregating data and a mechanism for speculative tracing. {DTrace} has been integrated into the Solaris operating system and has been used to find serious systemic performance problems on production systems-problems that could not be found using pre-existing facilities.},
	Address = {Berkeley, CA, USA},
	Author = {Cantrill, Bryan M. and Shapiro, Michael W. and Leventhal, Adam H.},
	Booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},
	Citeulike-Article-Id = {2605429},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1247417},
	Date-Added = {2014-01-20 16:41:02 +0000},
	Date-Modified = {2014-01-20 16:41:02 +0000},
	Location = {Boston, MA},
	Pages = {2},
	Posted-At = {2014-01-20 16:40:16},
	Priority = {2},
	Publisher = {USENIX Association},
	Series = {ATEC '04},
	Title = {Dynamic Instrumentation of Production Systems},
	Url = {http://portal.acm.org/citation.cfm?id=1247417},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRS4uLy4uL3BhcGVyL0NhbnQwNGEgRHluYW1pYyBJbnN0cnVtZW50YXRpb24gb2YgUHJvZHVjdGlvbiBTeXN0ZW1zLnBkZtIXCxgZV05TLmRhdGFPEQJMAAAAAAJMAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQ2FudDA0YSBEeW5hbWljIEluc3RyI0JDRkY4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvP+M8DEBkAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM8DAgkAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBDYW50MDRhIER5bmFtaWMgSW5zdHIjQkNGRjgucGRmAAAOAHQAOQBDAGEAbgB0ADAANABhACAARAB5AG4AYQBtAGkAYwAgAEkAbgBzAHQAcgB1AG0AZQBuAHQAYQB0AGkAbwBuACAAbwBmACAAUAByAG8AZAB1AGMAdABpAG8AbgAgAFMAeQBzAHQAZQBtAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGZVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DYW50MDRhIER5bmFtaWMgSW5zdHJ1bWVudGF0aW9uIG9mIFByb2R1Y3Rpb24gU3lzdGVtcy5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDWANsA4wMzAzUDOgNFA04DXANgA2cDcAN1A4IDhQOXA5oDnwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOh},
	Bdsk-Url-1 = {http://portal.acm.org/citation.cfm?id=1247417}}

@inproceedings{Kell12a,
	Abstract = {Bytecode instrumentation is a preferred technique for building profiling, debugging and monitoring tools targeting the Java Virtual Machine ({JVM}), yet is fundamentally dangerous. We illustrate its dangers with several examples gathered while building the {DiSL} instrumentation framework. We argue that no Java platform mechanism provides simultaneously adequate performance, reliability and expressiveness, but that this weakness is fixable. To elaborate, we contrast internal with external observation, and sketch some approaches and requirements for a hybrid mechanism.},
	Address = {New York, NY, USA},
	Author = {Kell, Stephen and Ansaloni, Danilo and Binder, Walter and Marek, Luk\'{a}\v{s}},
	Booktitle = {Proceedings of the Sixth ACM Workshop on Virtual Machines and Intermediate Languages},
	Citeulike-Article-Id = {12929005},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2414740.2414747},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2414740.2414747},
	Date-Added = {2014-01-20 14:59:38 +0000},
	Date-Modified = {2014-01-20 14:59:38 +0000},
	Doi = {10.1145/2414740.2414747},
	Isbn = {978-1-4503-1633-0},
	Location = {Tucson, Arizona, USA},
	Pages = {33--38},
	Posted-At = {2014-01-20 14:54:36},
	Priority = {2},
	Publisher = {ACM},
	Series = {VMIL '12},
	Title = {The {JVM} is Not Observable Enough (and What to Do About It)},
	Url = {http://dx.doi.org/10.1145/2414740.2414747},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QUi4uLy4uL3BhcGVyL0tlbGwxMmEgVGhlIEpWTSBpcyBOb3QgT2JzZXJ2YWJsZSBFbm91Z2ggKGFuZCBXaGF0IHRvIERvIEFib3V0IEl0KS5wZGbSFwsYGVdOUy5kYXRhTxECdAAAAAACdAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0tlbGwxMmEgVGhlIEpWTSBpcyBObyNCRDBGOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0PjPAvebAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADPAumLAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAS2VsbDEyYSBUaGUgSlZNIGlzIE5vI0JEMEY4LnBkZgAADgCOAEYASwBlAGwAbAAxADIAYQAgAFQAaABlACAASgBWAE0AIABpAHMAIABOAG8AdAAgAE8AYgBzAGUAcgB2AGEAYgBsAGUAIABFAG4AbwB1AGcAaAAgACgAYQBuAGQAIABXAGgAYQB0ACAAdABvACAARABvACAAQQBiAG8AdQB0ACAASQB0ACkALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHNVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9LZWxsMTJhIFRoZSBKVk0gaXMgTm90IE9ic2VydmFibGUgRW5vdWdoIChhbmQgV2hhdCB0byBEbyBBYm91dCBJdCkucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAOMA6ADwA2gDagNvA3oDgwORA5UDnAOlA6oDtwO6A8wDzwPUAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9Y=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2414740.2414747}}

@article{Wimm13a,
	Abstract = {A highly productive platform accelerates the production of research results. The design of a Virtual Machine ({VM}) written in the Java{\texttrademark} programming language can be simplified through exploitation of interfaces, type and memory safety, automated memory management (garbage collection), exception handling, and reflection. Moreover, modern Java {IDEs} offer time-saving features such as refactoring, auto-completion, and code navigation. Finally, Java annotations enable compiler extensions for low-level  '' systems programming'' while retaining {IDE} compatibility. These techniques collectively make complex system software more  '' approachable'' than has been typical in the past. The Maxine {VM}, a metacircular Java {VM} implementation, has aggressively used these features since its inception. A co-designed companion tool, the Maxine Inspector, offers integrated debugging and visualization of all aspects of the {VM}'s runtime state. The Inspector's implementation exploits advanced Java language features, embodies intimate knowledge of the {VM}'s design, and even reuses a significant amount of {VM} code directly. These characteristics make Maxine a highly approachable {VM} research platform and a productive basis for research and teaching.},
	Address = {New York, NY, USA},
	Author = {Wimmer, Christian and Haupt, Michael and Van De Vanter, Michael L. and Jordan, Mick and Dayn\`{e}s, Laurent and Simon, Douglas},
	Citeulike-Article-Id = {12073425},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2400682.2400689},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2400682.2400689},
	Date-Added = {2014-01-14 16:20:47 +0000},
	Date-Modified = {2014-01-14 16:20:47 +0000},
	Doi = {10.1145/2400682.2400689},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Month = jan,
	Number = {4},
	Posted-At = {2013-02-25 13:28:26},
	Priority = {2},
	Publisher = {ACM},
	Rating = {4},
	Read = {1},
	Title = {{Maxine}: An approachable virtual machine for, and in, {Java}},
	Url = {http://dx.doi.org/10.1145/2400682.2400689},
	Volume = {9},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QUC4uLy4uL3BhcGVyL1dpbW0xM2EgTWF4aW5lIEFuIGFwcHJvYWNoYWJsZSB2aXJ0dWFsIG1hY2hpbmUgZm9yLCBhbmQgaW4sIGphdmEucGRm0hcLGBlXTlMuZGF0YU8RAm4AAAAAAm4AAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9XaW1tMTNhIE1heGluZSBBbiBhcHAjQkQ0RDUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9TVzVGfmQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzVGRiQAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFdpbW0xM2EgTWF4aW5lIEFuIGFwcCNCRDRENS5wZGYAAA4AigBEAFcAaQBtAG0AMQAzAGEAIABNAGEAeABpAG4AZQAgAEEAbgAgAGEAcABwAHIAbwBhAGMAaABhAGIAbABlACAAdgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAIABmAG8AcgAsACAAYQBuAGQAIABpAG4ALAAgAGoAYQB2AGEALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHFVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9XaW1tMTNhIE1heGluZSBBbiBhcHByb2FjaGFibGUgdmlydHVhbCBtYWNoaW5lIGZvciwgYW5kIGluLCBqYXZhLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDhAOYA7gNgA2IDZwNyA3sDiQONA5QDnQOiA68DsgPEA8cDzAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPO},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2400682.2400689}}

@phdthesis{Verw12a,
	Abstract = {High-performance virtual machines (VMs) are increasingly reused for programming languages for which they were not initially designed. Unfortunately, VMs are usually tailored to specific languages, offer only a very limited interface to running applications, and are closed to extensions. As a consequence, extensions required to support new languages often entail the construction of custom VMs, thus impacting reuse, compatibility and performance. Short of building a custom VM, the language designer has to choose between the expressiveness and the performance of the language. In this dissertation we argue that the best way to open the VM is to eliminate it. We present Pinocchio, a natively compiled Smalltalk, in which we identify and reify three basic building blocks for object-oriented languages.  First we define a protocol for message passing similar to calling conventions, independent of the actual message lookup mechanism. The lookup is provided by a self-supporting runtime library written in Smalltalk and compiled to native code. Since it unifies the meta- and base-level we obtain a metaobject protocol (MOP).  Then we decouple the language-level manipulation of state from the machine-level implementation by extending the structural reflective model of the language with object layouts, layout scopes and slots.  Finally we reify behavior using AST nodes and first-class interpreters separate from the low-level language implementation. We describe the implementations of all three first-class building blocks. For each of the blocks we provide a series of examples illustrating how they enable typical extensions to the runtime, and we provide benchmarks validating the practicality of the approaches.},
	Author = {Toon Verwaest},
	Date-Added = {2014-01-07 20:20:43 +0000},
	Date-Modified = {2014-01-07 20:20:43 +0000},
	Keywords = {scg-phd snf-none jb12 pinocchio},
	Month = mar,
	School = {University of Bern},
	Title = {Bridging the Gap between Machine and Language using First-Class Building Blocks},
	Type = {PhD thesis},
	Url = {http://scg.unibe.ch/archive/phd/verwaest-phd.pdf},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QW1ZlcncxMmEgQnJpZGdpbmcgdGhlIEdhcCBiZXR3ZWVuIE1hY2hpbmUgYW5kIExhbmd1YWdlIHVzaW5nIEZpcnN0LUNsYXNzIEJ1aWxkaW5nIEJsb2Nrcy5wZGbSFwsYGVdOUy5kYXRhTxECfgAAAAACfgACAAADT1NYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyugn80grAAAGDHmQH1ZlcncxMmEgQnJpZGdpbmcgdGgjNkJENDU4MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa9RYDO8jmCAAAAAAAAAAAAAQACAAAJIAAAAAAAAAAAAAAAAAAAAAZ0aGVzaXMAEAAIAADK6BnjAAAAEQAIAADO8ityAAAAAQAUBgx5kAAOQVcACxyKAAZRzQAC5owAAgBNT1NYOlVzZXJzOgBjYW1pLWRhdGE6AGVkdWNhdGlvbjoAcGhkOgB0aGVzaXM6AFZlcncxMmEgQnJpZGdpbmcgdGgjNkJENDU4MC5wZGYAAA4AuABbAFYAZQByAHcAMQAyAGEAIABCAHIAaQBkAGcAaQBuAGcAIAB0AGgAZQAgAEcAYQBwACAAYgBlAHQAdwBlAGUAbgAgAE0AYQBjAGgAaQBuAGUAIABhAG4AZAAgAEwAYQBuAGcAdQBhAGcAZQAgAHUAcwBpAG4AZwAgAEYAaQByAHMAdAAtAEMAbABhAHMAcwAgAEIAdQBpAGwAZABpAG4AZwAgAEIAbABvAGMAawBzAC4AcABkAGYADwAIAAMATwBTAFgAEgCAVXNlcnMvY2FtaS1kYXRhL2VkdWNhdGlvbi9waGQvdGhlc2lzL1ZlcncxMmEgQnJpZGdpbmcgdGhlIEdhcCBiZXR3ZWVuIE1hY2hpbmUgYW5kIExhbmd1YWdlIHVzaW5nIEZpcnN0LUNsYXNzIEJ1aWxkaW5nIEJsb2Nrcy5wZGYAEwABLwAAFQACAAv//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDsAPEA+QN7A30DggONA5YDpAOoA68DuAO9A8oDzQPfA+ID5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPp},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/phd/verwaest-phd.pdf}}

@inproceedings{Lien08b,
	Abstract = {Back-in-time debuggers are extremely useful tools
                  for identifying the causes of bugs, as they allow us
                  to inspect the past states of objects no longer
                  present in the current execution stack.
                  Unfortunately the "omniscient" approaches that try
                  to remember all previous states are impractical
                  because they either consume too much space or they
                  are far too slow. Several approaches rely on
                  heuristics to limit these penalties, but they
                  ultimately end up throwing out too much relevant
                  information. In this paper we propose a practical
                  approach to back-in-time debugging that attempts to
                  keep track of only the relevant past data. In
                  contrast to other approaches, we keep object history
                  information together with the regular objects in the
                  application memory. Although seemingly
                  counter-intuitive, this approach has the effect that
                  past data that is not reachable from current
                  application objects (and hence, no longer relevant)
                  is automatically garbage collected. In this paper we
                  describe the technical details of our approach, and
                  we present benchmarks that demonstrate that memory
                  consumption stays within practical bounds.
                  Furthermore since our approach works at the virtual
                  machine level, the performance penalty is
                  significantly better than with other approaches.},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 22nd European Conference on Object-Oriented Programming (ECOOP'08)},
	Date-Added = {2014-01-07 10:43:48 +0000},
	Date-Modified = {2014-01-07 10:43:48 +0000},
	Doi = {10.1007/978-3-540-70592-5_25},
	Isbn = {978-3-540-70591-8},
	Keywords = {scg08 scg-pub object-flow snf08 jb08 girba},
	Medium = {2},
	Note = {{ECOOP} distinguished paper award},
	Pages = {592--615},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Practical Object-Oriented Back-in-Time Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Volume = {5142},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSC4uLy4uL3BhcGVyL0xpZW4wOGIgUHJhY3RpY2FsIE9iamVjdC1PcmllbnRlZCBCYWNrLWluLVRpbWUgRGVidWdnaW5nLnBkZtIXCxgZV05TLmRhdGFPEQJWAAAAAAJWAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfTGllbjA4YiBQcmFjdGljYWwgT2JqI0JEMTE3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvRF8ooq6UAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMooj4UAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBMaWVuMDhiIFByYWN0aWNhbCBPYmojQkQxMTcucGRmAAAOAHoAPABMAGkAZQBuADAAOABiACAAUAByAGEAYwB0AGkAYwBhAGwAIABPAGIAagBlAGMAdAAtAE8AcgBpAGUAbgB0AGUAZAAgAEIAYQBjAGsALQBpAG4ALQBUAGkAbQBlACAARABlAGIAdQBnAGcAaQBuAGcALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGlVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9MaWVuMDhiIFByYWN0aWNhbCBPYmplY3QtT3JpZW50ZWQgQmFjay1pbi1UaW1lIERlYnVnZ2luZy5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A2QDeAOYDQANCA0cDUgNbA2kDbQN0A30DggOPA5IDpAOnA6wAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADrg==},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-70592-5_25}}

@article{Arna13a,
	Abstract = {{Controlling object graphs and giving specific semantics to references (such as read-only, own- ership, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to be able to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is the underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementation of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.}},
	Affiliation = {RMOD - INRIA Lille - Nord Europe},
	Audience = {internationale},
	Author = {Arnaud, Jean-Baptiste and Ducasse, St{\'e}phane and Denker, Marcus},
	Date-Added = {2014-01-07 10:41:30 +0000},
	Date-Modified = {2014-01-07 10:41:30 +0000},
	Hal_Id = {hal-00881865},
	Journal = {Science of Computer Programming},
	Language = {Anglais},
	Month = Nov,
	Pdf = {http://hal.inria.fr/hal-00881865/PDF/Arna13b-Handles-ScienceOfComputerProgramming.pdf},
	Publisher = {Elsevier},
	Title = {{Handles: Behavior-Propagating First Class References For Dynamically-Typed Languages}},
	Url = {http://hal.inria.fr/hal-00881865},
	Year = {2013},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8Qay4uLy4uL3BhcGVyL0FybmExM2EgSGFuZGxlcyBCZWhhdmlvci1Qcm9wYWdhdGluZyBGaXJzdCBDbGFzcyBSZWZlcmVuY2VzIEZvciBEeW5hbWljYWxseS1UeXBlZCBMYW5ndWFnZXMucGRm0hcLGBlXTlMuZGF0YU8RAr4AAAAAAr4AAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9Bcm5hMTNhIEhhbmRsZXMgQmVoYXYjQkNGODkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8+JzvGYVQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzvGKRQAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AEFybmExM2EgSGFuZGxlcyBCZWhhdiNCQ0Y4OS5wZGYAAA4AwABfAEEAcgBuAGEAMQAzAGEAIABIAGEAbgBkAGwAZQBzACAAQgBlAGgAYQB2AGkAbwByAC0AUAByAG8AcABhAGcAYQB0AGkAbgBnACAARgBpAHIAcwB0ACAAQwBsAGEAcwBzACAAUgBlAGYAZQByAGUAbgBjAGUAcwAgAEYAbwByACAARAB5AG4AYQBtAGkAYwBhAGwAbAB5AC0AVAB5AHAAZQBkACAATABhAG4AZwB1AGEAZwBlAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAIxVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9Bcm5hMTNhIEhhbmRsZXMgQmVoYXZpb3ItUHJvcGFnYXRpbmcgRmlyc3QgQ2xhc3MgUmVmZXJlbmNlcyBGb3IgRHluYW1pY2FsbHktVHlwZWQgTGFuZ3VhZ2VzLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAPwBAQEJA8sDzQPSA90D5gP0A/gD/wQIBA0EGgQdBC8EMgQ3AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABDk=},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00881865}}

@inproceedings{Deut84a,
	Address = {Salt Lake City, Utah},
	Author = {L. Peter Deutsch and Allan M. Schiffman},
	Booktitle = {Proceedings POPL '84},
	Date-Added = {2013-12-17 21:35:44 +0000},
	Date-Modified = {2013-12-17 21:35:44 +0000},
	Doi = {10.1145/800017.800542},
	Keywords = {olit-oopl smalltalk casais popl84},
	Misc = {Jan. 15-18},
	Month = jan,
	Title = {Efficient Implementation of the {Smalltalk-80} system},
	Url = {http://webpages.charter.net/allanms/popl84.pdf},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSy4uLy4uL3BhcGVyL0RldXQ4NGEgRWZmaWNpZW50IEltcGxlbWVudGF0aW9uIG9mIHRoZSBTbWFsbHRhbGstODAgc3lzdGVtLnBkZtIXCxgZV05TLmRhdGFPEQJeAAAAAAJeAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfRGV1dDg0YSBFZmZpY2llbnQgSW1wI0JEMDUyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQUsisDUoAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMir8SoAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBEZXV0ODRhIEVmZmljaWVudCBJbXAjQkQwNTIucGRmAAAOAIAAPwBEAGUAdQB0ADgANABhACAARQBmAGYAaQBjAGkAZQBuAHQAIABJAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AIABvAGYAIAB0AGgAZQAgAFMAbQBhAGwAbAB0AGEAbABrAC0AOAAwACAAcwB5AHMAdABlAG0ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGxVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9EZXV0ODRhIEVmZmljaWVudCBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU21hbGx0YWxrLTgwIHN5c3RlbS5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDcAOEA6QNLA00DUgNdA2YDdAN4A38DiAONA5oDnQOvA7IDtwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAO5},
	Bdsk-Url-1 = {http://webpages.charter.net/allanms/popl84.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/800017.800542}}

@inproceedings{Verw10a,
	Abstract = {To support development tools like debuggers, runtime systems need to provide a meta-programming interface to alter their semantics and access internal data. Reflective capabilities are typically fixed by the Virtual Machine ({VM}). Unanticipated reflective features must either be simulated by complex program transformations, or they require the development of a specially tailored {VM}. We propose a novel approach to behavioral reflection that eliminates the barrier between applications and the {VM} by manipulating an explicit tower of first-class interpreters. Pinocchio is a proof-of-concept implementation of our approach which enables radical changes to the interpretation of programs by explicitly instantiating subclasses of the base interpreter. We illustrate the design of Pinocchio through non-trivial examples that extend runtime semantics to support debugging, parallel debugging, and back-in-time object-flow debugging. Although performance is not yet addressed, we also discuss numerous opportunities for optimization, which we believe will lead to a practical approach to behavioral reflection.},
	Address = {New York, NY, USA},
	Author = {Verwaest, Toon and Bruni, Camillo and Gurtner, David and Lienhard, Adrian and Niestrasz, Oscar},
	Booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
	Citeulike-Article-Id = {12819592},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1869522},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1869459.1869522},
	Date-Added = {2013-12-04 17:33:21 +0000},
	Date-Modified = {2013-12-04 17:33:21 +0000},
	Doi = {10.1145/1869459.1869522},
	Isbn = {978-1-4503-0203-6},
	Location = {Reno/Tahoe, Nevada, USA},
	Pages = {774--789},
	Posted-At = {2013-12-04 17:32:31},
	Priority = {2},
	Publisher = {ACM},
	Series = {OOPSLA '10},
	Title = {Pinocchio: Bringing Reflection to Life with First-class Interpreters},
	Url = {http://dx.doi.org/10.1145/1869459.1869522},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXC4uLy4uL3BhcGVyL1ZlcncxMGFiIFBpbm9jY2hpbyBCcmluZ2luZyBSZWZsZWN0aW9uIHRvIExpZmUgd2l0aCBGaXJzdC1jbGFzcyBJbnRlcnByZXRlcnMucGRm0hcLGBlXTlMuZGF0YU8RApIAAAAAApIAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9WZXJ3MTBhYiBQaW5vY2NoaW8gQnIjQkQ0QTEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9ShycTdsQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAycTBkQAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFZlcncxMGFiIFBpbm9jY2hpbyBCciNCRDRBMS5wZGYAAA4AogBQAFYAZQByAHcAMQAwAGEAYgAgAFAAaQBuAG8AYwBjAGgAaQBvACAAQgByAGkAbgBnAGkAbgBnACAAUgBlAGYAbABlAGMAdABpAG8AbgAgAHQAbwAgAEwAaQBmAGUAIAB3AGkAdABoACAARgBpAHIAcwB0AC0AYwBsAGEAcwBzACAASQBuAHQAZQByAHAAcgBlAHQAZQByAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAH1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9WZXJ3MTBhYiBQaW5vY2NoaW8gQnJpbmdpbmcgUmVmbGVjdGlvbiB0byBMaWZlIHdpdGggRmlyc3QtY2xhc3MgSW50ZXJwcmV0ZXJzLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDtAPIA+gOQA5IDlwOiA6sDuQO9A8QDzQPSA98D4gP0A/cD/AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAP+},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1869459.1869522}}

@inproceedings{Fish00a,
	Abstract = {Practical implementations of high-level languages must provide access to libraries and system  services that have {APIs} specified in a low-level language (usually C). Our approach to  supporting foreign interfaces in the {MOBY} compiler is based on a mechanism for data-level  interoperability, which allows {MOBY} code to manipulate C data representations directly. Datalevel  interoperability is important when dealing with large external data sets or data that is in  a fixed format. It also serves as the foundation for a wide range of different foreign-interface  policies. We describe tools that implement three such policies: Charon, which embeds C types  directly into {MOBY}, moby-idl, which provides an {IDL}-based embedding, and an {API} miner,  which enables application-specific embeddings. The benefits of our approach stem from the  design of our compiler and do not rely on properties of the {MOBY} language.  1 Introduction  High-level languages, such as most functional and object-oriented langu...},
	Author = {Fisher, Kathleen and Pucella, Riccardo and Reppy, John},
	Booktitle = {Electronic Notes in Theoretical Computer Science},
	Citeulike-Article-Id = {12819568},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965},
	Date-Added = {2013-12-04 17:12:09 +0000},
	Date-Modified = {2013-12-04 17:12:09 +0000},
	Doi = {10.1.1.43.4965},
	Posted-At = {2013-12-04 17:11:42},
	Priority = {2},
	Title = {{Data-Level} Interoperability},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMy4uLy4uL3BhcGVyL0Zpc2gwMGEgRGF0YS1MZXZlbCBJbnRlcm9wZXJhYmlsaXR5LnBkZtIXCxgZV05TLmRhdGFPEQIWAAAAAAIWAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfRmlzaDAwYSBEYXRhLUxldmVsIEluI0JEMDY3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQZ87FINEAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAM7FEsEAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBGaXNoMDBhIERhdGEtTGV2ZWwgSW4jQkQwNjcucGRmAAAOAFAAJwBGAGkAcwBoADAAMABhACAARABhAHQAYQAtAEwAZQB2AGUAbAAgAEkAbgB0AGUAcgBvAHAAZQByAGEAYgBpAGwAaQB0AHkALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAFRVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9GaXNoMDBhIERhdGEtTGV2ZWwgSW50ZXJvcGVyYWJpbGl0eS5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDEAMkA0QLrAu0C8gL9AwYDFAMYAx8DKAMtAzoDPQNPA1IDVwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANZ},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.4965}}

@inproceedings{Repp06b,
	Acmid = {1173714},
	Address = {New York, NY, USA},
	Author = {Reppy, John and Song, Chunyan},
	Booktitle = {Proceedings of the 5th international conference on Generative programming and component engineering},
	Date-Added = {2013-12-04 17:08:38 +0000},
	Date-Modified = {2013-12-04 17:08:38 +0000},
	Doi = {10.1145/1173706.1173714},
	Isbn = {1-59593-237-2},
	Keywords = {foreign-interface generation, term rewriting},
	Location = {Portland, Oregon, USA},
	Numpages = {10},
	Pages = {49--58},
	Publisher = {ACM},
	Series = {GPCE '06},
	Title = {Application-specific foreign-interface generation},
	Url = {http://doi.acm.org/10.1145/1173706.1173714},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSS4uLy4uL3BhcGVyL1JlcHAwNmIgQXBwbGljYXRpb24tc3BlY2lmaWMgZm9yZWlnbi1pbnRlcmZhY2UgZ2VuZXJhdGlvbi5wZGbSFwsYGVdOUy5kYXRhTxECWAAAAAACWAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1JlcHAwNmIgQXBwbGljYXRpb24tcyNCRDFCMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0bHOxSATAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADOxRIDAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAUmVwcDA2YiBBcHBsaWNhdGlvbi1zI0JEMUIxLnBkZgAADgB8AD0AUgBlAHAAcAAwADYAYgAgAEEAcABwAGwAaQBjAGEAdABpAG8AbgAtAHMAcABlAGMAaQBmAGkAYwAgAGYAbwByAGUAaQBnAG4ALQBpAG4AdABlAHIAZgBhAGMAZQAgAGcAZQBuAGUAcgBhAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGpVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9SZXBwMDZiIEFwcGxpY2F0aW9uLXNwZWNpZmljIGZvcmVpZ24taW50ZXJmYWNlIGdlbmVyYXRpb24ucGRmABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A2gDfAOcDQwNFA0oDVQNeA2wDcAN3A4ADhQOSA5UDpwOqA68AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADsQ==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1173706.1173714}}

@inproceedings{Blac04a,
	Acmid = {999420},
	Address = {Washington, DC, USA},
	Author = {Blackburn, Stephen M. and Cheng, Perry and McKinley, Kathryn S.},
	Booktitle = {Proceedings of the 26th International Conference on Software Engineering},
	Date-Added = {2013-12-04 17:07:19 +0000},
	Date-Modified = {2013-12-04 17:07:19 +0000},
	Doi = {10.1.1.123.2069},
	Isbn = {0-7695-2163-0},
	Numpages = {10},
	Pages = {137--146},
	Publisher = {IEEE Computer Society},
	Series = {ICSE '04},
	Title = {Oil and Water? {High} Performance Garbage Collection in {Java} with {MMTk}},
	Url = {http://dl.acm.org/citation.cfm?id=998675.999420},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXC4uLy4uL3BhcGVyL0JsYWMwNGEgT2lsIGFuZCBXYXRlcj8gSGlnaCBQZXJmb3JtYW5jZSBHYXJiYWdlIENvbGxlY3Rpb24gaW4gSmF2YSB3aXRoIE1NVGsucGRm0hcLGBlXTlMuZGF0YU8RApIAAAAAApIAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9CbGFjMDRhIE9pbCBhbmQgV2F0ZXIjQkNGQTcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8+nzsUfjgAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzsURfgAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AEJsYWMwNGEgT2lsIGFuZCBXYXRlciNCQ0ZBNy5wZGYAAA4AogBQAEIAbABhAGMAMAA0AGEAIABPAGkAbAAgAGEAbgBkACAAVwBhAHQAZQByAD8AIABIAGkAZwBoACAAUABlAHIAZgBvAHIAbQBhAG4AYwBlACAARwBhAHIAYgBhAGcAZQAgAEMAbwBsAGwAZQBjAHQAaQBvAG4AIABpAG4AIABKAGEAdgBhACAAdwBpAHQAaAAgAE0ATQBUAGsALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAH1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9CbGFjMDRhIE9pbCBhbmQgV2F0ZXI/IEhpZ2ggUGVyZm9ybWFuY2UgR2FyYmFnZSBDb2xsZWN0aW9uIGluIEphdmEgd2l0aCBNTVRrLnBkZgAAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDtAPIA+gOQA5IDlwOiA6sDuQO9A8QDzQPSA98D4gP0A/cD/AAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAP+},
	Bdsk-Url-1 = {http://dl.acm.org/citation.cfm?id=998675.999420}}

@inproceedings{Ande98a,
	Abstract = {This is a note on reflection in Python 1.5. Both this and earlier versions of Python has an open implementation where we can access and alter the internal structures of language components. Python 1.5 takes this one step further making it even easier to adapt a reflective programming model. These dynamic features of Python were one of the reasons for chosing it as the language used to implement an experimental reflective middleware platform in the {SUMO} {II} project. We will in this note describe the open implementation in Python 1.5 and show how it can be used to achieve a reflective programming model. The note also includes a description of our reflection module for Python. 1 Introduction  Python 1.4, which was the previous release of Python, was recognized as a good choice for a language implementing a experimental reflective middleware platform in the {SUMO} {II} project [1]. All the dynamic features in the language made it possible to go behind the scene and inspect and change the behavi...},
	Author = {Andersen, Anders},
	Booktitle = {Lancaster University},
	Citeulike-Article-Id = {12212143},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504},
	Date-Added = {2013-12-04 16:55:50 +0000},
	Date-Modified = {2013-12-04 16:55:50 +0000},
	Doi = {10.1.1.50.9504},
	Posted-At = {2013-03-26 13:34:38},
	Priority = {2},
	Title = {A note on reflection in Python 1.5},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504},
	Year = {1998},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9504}}

@mastersthesis{Brun11a,
	Abstract = {Optimizations are an omnipresent topic when working on Virtual Machines (VMs). There is a
		plethora of different optimizations available ranging from simple tweaks and tricks to full
        evaluation concepts requiring a complex infrastructure. Depending on the complexity of an
        optimization and the performance increase it is important to choose the right kinds of optimizations.
        Based on a high-level language VM as a case study we argue in favor of transparent optimizations
        which do not require changes in the interpreted language's semantics. Furthermore it is necessary to
        write and properly evaluate benchmarks to be able to track the performance impact of a certain
        optimization. When building a high-level language VM the underlying system -- traditionally a C or
        C++ core -- does not share many concepts with the implemented language. Hence some optimizations
        emerging from the low-level VM core are orthogonal to the high-level concepts of the interpreted
        language. Focusing on such optimizations can strongly limit the dynamic capabilities of a high-level
        language. These non-transparent optimizations require the semantics of the interpreted language to be
        changed. Changes in the language's semantics can require extensive changes in the sources which is an
        undesired property. However transparent optimizations preserve semantics of the language. Using
        transparent optimizations helps to separate the low-level requirements of the VM form the high-level
        design decisions of the language. We argue that non-transparent optimizations should only be applied
        to a high-level language VM in an early development stage. Furthermore each non-transparent
        optimization should be paired with a compatible way to reintroduce the lost or altered semantics. To
        make valid statements about optimizations it is necessary to write adequate benchmarks. The
        benchmarks have to be reproducible and the evaluation has to be statistically sound, furthermore the
        benchmarks should focus on covering specific use cases to help locating performance issues in the VM
        code. Benchmarks are to be used in a similar way as unit tests. Optimizations can only be evaluated
        in a sound way when the corresponding benchmarks produce deterministic values. Furthermore we state
        that focusing on micro benchmarks helps to locate and track performance critical code segments of the
        VM.},
	Added-At = {2011-02-05T16:38:54.000+0100},
	Author = {Bruni, Camillo},
	Biburl = {http://www.bibsonomy.org/bibtex/288adb7c61909729df1b12184fb13cb66/gron},
	Date-Added = {2013-12-04 16:53:48 +0000},
	Date-Modified = {2013-12-04 16:53:48 +0000},
	Interhash = {9c6b78e09362e9033baf90c80ce6a845},
	Intrahash = {88adb7c61909729df1b12184fb13cb66},
	Keywords = {Debugger Optimization Parallel Pinocchio VM},
	Month = jan,
	School = {University of Bern},
	Timestamp = {2011-02-05T16:38:54.000+0100},
	Title = {{Optimizing Pinocchio}},
	Type = {Master's Thesis},
	Url = {http://scg.unibe.ch/archive/masters/Brun11a.pdf},
	Year = 2011,
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/masters/Brun11a.pdf}}

@article{Verw11a,
	Abstract = {Programming idioms, design patterns and application libraries often introduce cumbersome and repetitive boilerplate code to a software system. Language extensions and external {DSLs} (domain specific languages) are sometimes introduced to reduce the need for boilerplate code, but they also complicate the system by introducing the need for language dialects and inter-language mediation. To address this, we propose to extend the structural reflective model of the language with object layouts, layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to object layouts that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language extensions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported. We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples.},
	Address = {New York, NY, USA},
	Author = {Verwaest, Toon and Bruni, Camillo and Lungu, Mircea and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications},
	Citeulike-Article-Id = {10181088},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2048066.2048138},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2048066.2048138},
	Date-Added = {2013-12-04 16:53:39 +0000},
	Date-Modified = {2013-12-04 16:53:39 +0000},
	Doi = {10.1145/2048066.2048138},
	Isbn = {978-1-4503-0940-0},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Location = {Portland, Oregon, USA},
	Month = oct,
	Number = {10},
	Pages = {959--972},
	Posted-At = {2013-11-11 15:13:01},
	Priority = {2},
	Publisher = {ACM},
	Series = {OOPSLA '11},
	Title = {Flexible object layouts: enabling lightweight language extensions by intercepting slot access},
	Url = {http://dx.doi.org/10.1145/2048066.2048138},
	Volume = {46},
	Year = {2011},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2048066.2048138}}

@inproceedings{Chis12a,
	Abstract = {Smalltalk, in spite of myriad advantages in terms of ease of development, has been largely eclipsed by lower-level languages like C, which has become the lingua franca on modern systems. This paper introduces the Pragmatic Smalltalk compiler, which provides a dialect of Smalltalk that is designed from the ground up for close interoperability with C libraries. We describe how high-level Smalltalk language features are lowered to allow execution without a virtual machine, allowing Smalltalk and C code to be mixed in the same program without hard boundaries between the two. This allows incremental deployment of Smalltalk code in programs and libraries along with heavily optimised low-level C and assembly routines for performance critical segments.},
	Address = {New York, NY, USA},
	Author = {Chisnall, David},
	Booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
	Citeulike-Article-Id = {12438519},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=2448963.2448967},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/2448963.2448967},
	Date-Added = {2013-12-04 16:53:33 +0000},
	Date-Modified = {2013-12-04 16:53:33 +0000},
	Doi = {10.1145/2448963.2448967},
	Isbn = {978-1-4503-1897-6},
	Location = {Ghent, Belgium},
	Posted-At = {2013-06-19 15:27:49},
	Priority = {2},
	Publisher = {ACM},
	Series = {IWST '12},
	Title = {{Smalltalk} in a {C} world},
	Url = {http://dx.doi.org/10.1145/2448963.2448967},
	Year = {2012},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLi4uLy4uL3BhcGVyL0NoaXMxMmEgU21hbGx0YWxrIGluIGEgQyB3b3JsZC5wZGbSFwsYGVdOUy5kYXRhTxECCAAAAAACCAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0NoaXMxMmEgU21hbGx0YWxrIGluICNCRDAwOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0AjN55GGAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADN53VmAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAQ2hpczEyYSBTbWFsbHRhbGsgaW4gI0JEMDA4LnBkZgAADgBGACIAQwBoAGkAcwAxADIAYQAgAFMAbQBhAGwAbAB0AGEAbABrACAAaQBuACAAYQAgAEMAIAB3AG8AcgBsAGQALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAE9Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DaGlzMTJhIFNtYWxsdGFsayBpbiBhIEMgd29ybGQucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAL8AxADMAtgC2gLfAuoC8wMBAwUDDAMVAxoDJwMqAzwDPwNEAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0Y=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2448963.2448967}}

@article{Ball86a,
	Abstract = {{QUICKTALK} is a dialect of Smalltalk-80 that can be compiled directly into native machine code, instead of virtual machine bytecodes. The dialect includes  '' hints'' on the class of method arguments, instance variables, and class variables. We designed the dialect to describe primitive Smalltalk methods. {QUICKTALK} achieves improved performance over bytecodes by eliminating the interpreter loop on bytecode execution, by reducing the number of message send/returns via binding some target methods at compilation, and by eliminating redundant class checking. We identify changes to the Smalltalk-80 system and compiler to support the dialect, and give performance measurements.},
	Address = {New York, NY, USA},
	Author = {Ballard, Mark B. and Maier, David and Brock, Allen W.},
	Citeulike-Article-Id = {10744787},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=28697.28711},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/960112.28711},
	Date-Added = {2013-12-04 16:53:29 +0000},
	Date-Modified = {2013-12-04 16:53:29 +0000},
	Doi = {10.1145/960112.28711},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = jun,
	Number = {11},
	Pages = {140--150},
	Posted-At = {2012-06-05 12:41:15},
	Priority = {2},
	Publisher = {ACM},
	Rating = {3},
	Read = {1},
	Title = {{QUICKTALK}: a {Smalltalk-80} dialect for defining primitive methods},
	Url = {http://dx.doi.org/10.1145/960112.28711},
	Volume = {21},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QVy4uLy4uL3BhcGVyL0JhbGw4NmEgUVVJQ0tUQUxLIGEgU21hbGx0YWxrLTgwIGRpYWxlY3QgZm9yIGRlZmluaW5nIHByaW1pdGl2ZSBtZXRob2RzLnBkZtIXCxgZV05TLmRhdGFPEQKCAAAAAAKCAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQmFsbDg2YSBRVUlDS1RBTEsgYSBTI0JDRjk5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvPmcvuynoAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMvurloAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBCYWxsODZhIFFVSUNLVEFMSyBhIFMjQkNGOTkucGRmAAAOAJgASwBCAGEAbABsADgANgBhACAAUQBVAEkAQwBLAFQAQQBMAEsAIABhACAAUwBtAGEAbABsAHQAYQBsAGsALQA4ADAAIABkAGkAYQBsAGUAYwB0ACAAZgBvAHIAIABkAGUAZgBpAG4AaQBuAGcAIABwAHIAaQBtAGkAdABpAHYAZQAgAG0AZQB0AGgAbwBkAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHhVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9CYWxsODZhIFFVSUNLVEFMSyBhIFNtYWxsdGFsay04MCBkaWFsZWN0IGZvciBkZWZpbmluZyBwcmltaXRpdmUgbWV0aG9kcy5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDoAO0A9QN7A30DggONA5YDpAOoA68DuAO9A8oDzQPfA+ID5wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPp},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/960112.28711}}

@inproceedings{Kell11a,
	Annote = {internationalworkshop},
	Author = {Stephen Kell and Conrad Irwin},
	Booktitle = {VMIL '11: Proceedings of the 5th workshop on Virtual machines and intermediate languages for emerging modularization mechanisms},
	Date-Added = {2013-12-04 16:53:26 +0000},
	Date-Modified = {2013-12-04 16:53:26 +0000},
	Location = {Portland, Oregon, U.S.A.},
	Pages = {6},
	Publisher = {ACM},
	Rating = {4},
	Read = {1},
	Title = {Virtual machines should be invisible},
	Url = {http://www.cs.iastate.edu/~design/vmil/2011/papers/p02-kell.pdf},
	Year = {2011},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QPC4uLy4uL3BhcGVyL0tlbGwxMWEgVmlydHVhbCBtYWNoaW5lcyBzaG91bGQgYmUgaW52aXNpYmxlLnBkZtIXCxgZV05TLmRhdGFPEQIyAAAAAAIyAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfS2VsbDExYSBWaXJ0dWFsIG1hY2hpI0JEMEY3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQ98sOZjAAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMsOWCAAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBLZWxsMTFhIFZpcnR1YWwgbWFjaGkjQkQwRjcucGRmAAAOAGIAMABLAGUAbABsADEAMQBhACAAVgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAcwAgAHMAaABvAHUAbABkACAAYgBlACAAaQBuAHYAaQBzAGkAYgBsAGUALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAF1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9LZWxsMTFhIFZpcnR1YWwgbWFjaGluZXMgc2hvdWxkIGJlIGludmlzaWJsZS5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AzQDSANoDEAMSAxcDIgMrAzkDPQNEA00DUgNfA2IDdAN3A3wAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADfg==},
	Bdsk-Url-1 = {http://www.cs.iastate.edu/~design/vmil/2011/papers/p02-kell.pdf}}

@article{Bolz08a,
	Abstract = {We report on our experiences with the  Spy  project, including implementation details and benchmark results.  Spy  is a re-implementation of the Squeak ( i.e.  Smalltalk-80) VM using the PyPy toolchain. The PyPy project allows code written in RPython, a subset of Python, to be translated to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters can be derived from one abstract interpreter definition.  Spy  aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current  Spy  codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk VMs, but which still run slower than in Squeak itself.  Spy  was built from scratch over the course of a week during a joint Squeak-PyPy Sprint in Bern last autumn.},
	Address = {Berlin, Heidelberg},
	Author = {Bolz, Carl F. and Kuhn, Adrian and Lienhard, Adrian and Matsakis, Nicholas D. and Nierstrasz, Oscar and Renggli, Lukas and Rigo, Armin and Verwaest, Toon},
	Citeulike-Article-Id = {5033558},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1482373.1482382},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	Citeulike-Linkout-2 = {http://www.springerlink.com/content/n5v3uu17u4t51432},
	Date-Added = {2013-12-04 16:53:14 +0000},
	Date-Modified = {2013-12-04 16:53:14 +0000},
	Doi = {10.1007/978-3-540-89275-5_7},
	Isbn = {978-3-540-89274-8},
	Journal = {Self-Sustaining Systems},
	Keywords = {pypy, sprint},
	Pages = {123--139},
	Posted-At = {2010-08-16 14:33:20},
	Priority = {2},
	Publisher = {Springer-Verlag},
	Read = {1},
	Title = {Back to the Future in One Week -- Implementing a {Smalltalk} VM in {PyPy}},
	Url = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXS4uLy4uL3BhcGVyL0JvbHowOGEgQmFjayB0byB0aGUgRnV0dXJlIGluIE9uZSBXZWVrIC0tIEltcGxlbWVudGluZyBhIFNtYWxsdGFsayBWTSBpbiBQeVB5LnBkZtIXCxgZV05TLmRhdGFPEQKUAAAAAAKUAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfQm9sejA4YSBCYWNrIHRvIHRoZSBGI0JDRkIwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvPsMiPCuYAAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMiO7sYAAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBCb2x6MDhhIEJhY2sgdG8gdGhlIEYjQkNGQjAucGRmAAAOAKQAUQBCAG8AbAB6ADAAOABhACAAQgBhAGMAawAgAHQAbwAgAHQAaABlACAARgB1AHQAdQByAGUAIABpAG4AIABPAG4AZQAgAFcAZQBlAGsAIAAtAC0AIABJAG0AcABsAGUAbQBlAG4AdABpAG4AZwAgAGEAIABTAG0AYQBsAGwAdABhAGwAawAgAFYATQAgAGkAbgAgAFAAeQBQAHkALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAH5Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9Cb2x6MDhhIEJhY2sgdG8gdGhlIEZ1dHVyZSBpbiBPbmUgV2VlayAtLSBJbXBsZW1lbnRpbmcgYSBTbWFsbHRhbGsgVk0gaW4gUHlQeS5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDuAPMA+wOTA5UDmgOlA64DvAPAA8cD0APVA+ID5QP3A/oD/wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQB},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-540-89275-5_7}}

@inproceedings{Unga07a,
	Abstract = {The years 1985 through 1995 saw the birth and development of the language Self, starting from its design by the authors at Xerox {PARC}, through first implementations by Ungar and his graduate students at Stanford University, and then with a larger team formed when the authors joined Sun Microsystems Laboratories in 1991. Self was designed to help programmers become more productive and creative by giving them a simple, pure, and powerful language, an implementation that combined ease of use with high performance, a user interface that off-loaded cognitive burden, and a programming environment that captured the malleability of a physical world of live objects. Accomplishing these goals required innovation in several areas: a simple yet powerful prototype-based object model for mainstream programming, many compilation techniques including customization, splitting, type prediction, polymorphic inline caches, adaptive optimization, and dynamic deoptimization, the application of cartoon animation to enhance the legibility of a dynamic graphical interface, an object-centered programming environment, and a user-interface construction framework that embodied a uniform use-mention distinction. Over the years, the project has published many papers and released four major versions of Self. Although the Self project ended in 1995, its implementation, animation, user interface toolkit architecture, and even its prototype object model impact computer science today (2006). Java virtual machines for desktop and laptop computers have adopted Self's implementation techniques, many user interfaces incorporate cartoon animation, several popular systems have adopted similar interface frameworks, and the prototype object model can be found in some of today's languages, including {JavaScript}. Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved.},
	Address = {New York, NY, USA},
	Author = {Ungar, David and Smith, Randall B.},
	Booktitle = {Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Citeulike-Article-Id = {5920806},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1238844.1238853},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1238844.1238853},
	Date-Added = {2013-12-04 16:53:05 +0000},
	Date-Modified = {2013-12-04 16:53:05 +0000},
	Doi = {10.1145/1238844.1238853},
	Isbn = {978-1-59593-766-7},
	Location = {San Diego, California},
	Posted-At = {2011-01-20 10:03:09},
	Priority = {2},
	Publisher = {ACM},
	Read = {1},
	Series = {HOPL III},
	Title = {{Self}},
	Url = {http://dx.doi.org/10.1145/1238844.1238853},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QHS4uLy4uL3BhcGVyL1VuZ2EwN2FhIFNlbGYucGRm0hcLGBlXTlMuZGF0YU8RAcYAAAAAAcYAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmxFVbmdhMDdhYSBTZWxmLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9SUzXYPFQAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAzXYBBQAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAU1NhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFVuZ2EwN2FhIFNlbGYucGRmAAAOACQAEQBVAG4AZwBhADAANwBhAGEAIABTAGUAbABmAC4AcABkAGYADwAgAA8AUwBhAG0AcwB1AG4AZwAgAFMAUwBEACAAOAA0ADAAEgA+VXNlcnMvY2FtaWxsb2JydW5pL0RvY3VtZW50cy9lZHVjYXRpb24vcGFwZXIvVW5nYTA3YWEgU2VsZi5wZGYAEwABLwAAFQACABP//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgCuALMAuwKFAocCjAKXAqACrgKyArkCwgLHAtQC1wLpAuwC8QAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAALz},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1238844.1238853}}

@inproceedings{Rigo06a,
	Abstract = {The PyPy project seeks to prove both on a research and a practical level the feasibility of constructing a virtual machine (VM) for a dynamic language in a dynamic language - in this case, Python. The aim is to translate (i.e. compile) the VM to arbitrary target environments, ranging in level from C/Posix to Smalltalk/Squeak via Java and CLI/.NET, while still being of reasonable efficiency within these environments.A key tool to achieve this goal is the systematic reuse of the Python language as a system programming language at various levels of our architecture and translation process. For each level, we design a corresponding type system and apply a generic type inference engine - for example, the garbage collector is written in a style that manipulates simulated pointer and address objects, and when translated to C these operations become C-level pointer and address instructions.},
	Address = {New York, NY, USA},
	Author = {Rigo, Armin and Pedroni, Samuele},
	Booktitle = {OOPSLA '06: Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications},
	Citeulike-Article-Id = {4464460},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1176753},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1176617.1176753},
	Date-Added = {2013-12-04 16:53:01 +0000},
	Date-Modified = {2013-12-04 16:53:01 +0000},
	Doi = {10.1145/1176617.1176753},
	Isbn = {1-59593-491-X},
	Location = {Portland, Oregon, USA},
	Pages = {944--953},
	Posted-At = {2010-08-15 16:00:00},
	Priority = {2},
	Publisher = {ACM},
	Title = {{PyPy}'s approach to virtual machine construction},
	Url = {http://dx.doi.org/10.1145/1176617.1176753},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRy4uLy4uL3BhcGVyL1JpZ28wNmEgUHlQeSdzIGFwcHJvYWNoIHRvIHZpcnR1YWwgbWFjaGluZSBjb25zdHJ1Y3Rpb24ucGRm0hcLGBlXTlMuZGF0YU8RAlIAAAAAAlIAAgAAD1NhbXN1bmcgU1NEIDg0MAAAAAAAAAAAAAAAAM9h1xRIKwAAAAvOmx9SaWdvMDZhIFB5UHkncyBhcHByb2EjQkQxQjYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC9G2yBTBAwAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAFcGFwZXIAABAACAAAz2G69AAAABEACAAAyBSk4wAAAAEAFAALzpsABigwAAYkvwAGJIIAAmWvAAIAYVNhbXN1bmcgU1NEIDg0MDpVc2VyczoAY2FtaWxsb2JydW5pOgBEb2N1bWVudHM6AGVkdWNhdGlvbjoAcGFwZXI6AFJpZ28wNmEgUHlQeSdzIGFwcHJvYSNCRDFCNi5wZGYAAA4AeAA7AFIAaQBnAG8AMAA2AGEAIABQAHkAUAB5ACcAcwAgAGEAcABwAHIAbwBhAGMAaAAgAHQAbwAgAHYAaQByAHQAdQBhAGwAIABtAGEAYwBoAGkAbgBlACAAYwBvAG4AcwB0AHIAdQBjAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAGhVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9SaWdvMDZhIFB5UHkncyBhcHByb2FjaCB0byB2aXJ0dWFsIG1hY2hpbmUgY29uc3RydWN0aW9uLnBkZgATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOANgA3QDlAzsDPQNCA00DVgNkA2gDbwN4A30DigONA58DogOnAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6k=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1176617.1176753}}

@inproceedings{Unga05a,
	Address = {New York, NY, USA},
	Author = {Ungar, David and Spitz, Adam and Ausch, Alex},
	Booktitle = {OOPSLA '05: Companion to the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2013-12-04 16:52:53 +0000},
	Date-Modified = {2013-12-04 16:52:53 +0000},
	Doi = {10.1145/1094855.1094865},
	Isbn = {1-59593-193-7},
	Keywords = {klein},
	Location = {San Diego, CA, USA},
	Pages = {11--20},
	Publisher = {ACM},
	Rating = {5},
	Read = {1},
	Title = {Constructing a metacircular Virtual machine in an exploratory programming environment},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QbS4uLy4uL3BhcGVyL1VuZ2EwNWEgQ29uc3RydWN0aW5nIGEgbWV0YWNpcmN1bGFyIFZpcnR1YWwgbWFjaGluZSBpbiBhbiBleHBsb3JhdG9yeSBwcm9ncmFtbWluZyBlbnZpcm9ubWVudC5wZGbSFwsYGVdOUy5kYXRhTxECxAAAAAACxAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1VuZ2EwNWEgQ29uc3RydWN0aW5nICNCRDQ5MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL1JDOXu5PAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADOXtIvAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAVW5nYTA1YSBDb25zdHJ1Y3RpbmcgI0JENDkwLnBkZgAADgDEAGEAVQBuAGcAYQAwADUAYQAgAEMAbwBuAHMAdAByAHUAYwB0AGkAbgBnACAAYQAgAG0AZQB0AGEAYwBpAHIAYwB1AGwAYQByACAAVgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAIABpAG4AIABhAG4AIABlAHgAcABsAG8AcgBhAHQAbwByAHkAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABlAG4AdgBpAHIAbwBuAG0AZQBuAHQALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAI5Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9VbmdhMDVhIENvbnN0cnVjdGluZyBhIG1ldGFjaXJjdWxhciBWaXJ0dWFsIG1hY2hpbmUgaW4gYW4gZXhwbG9yYXRvcnkgcHJvZ3JhbW1pbmcgZW52aXJvbm1lbnQucGRmABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A/gEDAQsD0wPVA9oD5QPuA/wEAAQHBBAEFQQiBCUENwQ6BD8AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAEQQ==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1094855.1094865}}

@inproceedings{Male96a,
	Abstract = {The efficient implementation of behaviorally reflective languages imposes a formidable challenge. By definition, behavioral reflection allows a program to modify even at runtime, its own code as well as the semantics and the implementation of its own programming language. This late-binding of the language semantics favors interpretive techniques, but compilers are absolutely necessary to make reflective languages efficient and therefore of real interest. The goals of this tutorial are to give the picture of the state of the art in the efficient implementation of behavioral reflection, to review the main issues in going from interpreter-based to compiler-based implementations and to propose new avenues towards the realization of this objective. Our tutorial is aimed at a large audience of reflective language implementors, in either object-oriented, functional or even logic programming. To make our point widely applicable, we avoid fine grain technicalities. Rather we emphasize the common denominator of all reflective languages, we propose a clear and general problem statement, and we set up a wide-ranging research agenda},
	Annote = {Contains various definitions of terms related to reflection.
- Reflection
- reflective mechanism
- structural reflection
- behavioral reflection
- discrete and continous reflection
- binding, formal-binding time, actual binding time},
	Author = {Malenfant, J. and Jacques, M. and Demers, F. N.},
	Booktitle = {Proceedings of the First International Conference on Reflection},
	Citeulike-Article-Id = {6483507},
	Date-Added = {2013-12-04 16:52:46 +0000},
	Date-Modified = {2014-05-19 17:22:24 +0000},
	Keywords = {jamoma},
	Posted-At = {2010-01-04 16:04:52},
	Priority = {2},
	Rating = {5},
	Read = {1},
	Series = {Reflection'96},
	Title = {A tutorial on behavioral reflection and its implementation},
	Url = {http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/malenfant.pdf},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QUi4uLy4uL3BhcGVyL01hbGU5NmEgQSB0dXRvcmlhbCBvbiBiZWhhdmlvcmFsIHJlZmxlY3Rpb24gYW5kIGl0cyBpbXBsZW1lbnRhdGlvbi5wZGbSFwsYGVdOUy5kYXRhTxECdAAAAAACdAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH01hbGU5NmEgQSB0dXRvcmlhbCBvbiNCRDE1My5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0VPNXluGAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADNXk12AAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoATWFsZTk2YSBBIHR1dG9yaWFsIG9uI0JEMTUzLnBkZgAADgCOAEYATQBhAGwAZQA5ADYAYQAgAEEAIAB0AHUAdABvAHIAaQBhAGwAIABvAG4AIABiAGUAaABhAHYAaQBvAHIAYQBsACAAcgBlAGYAbABlAGMAdABpAG8AbgAgAGEAbgBkACAAaQB0AHMAIABpAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4ALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAHNVc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9NYWxlOTZhIEEgdHV0b3JpYWwgb24gYmVoYXZpb3JhbCByZWZsZWN0aW9uIGFuZCBpdHMgaW1wbGVtZW50YXRpb24ucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAOMA6ADwA2gDagNvA3oDgwORA5UDnAOlA6oDtwO6A8wDzwPUAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9Y=}}

@article{Van10a,
	Abstract = {Proxies are a powerful approach to implement meta-objects in object-oriented languages without having to resort to metacircular interpretation. We introduce such a meta-level {API} based on proxies for Javascript. We simultaneously introduce a set of design principles that characterize such {APIs} in general, and compare similar {APIs} of other languages in terms of these principles. We highlight how principled proxy-based {APIs} improve code robustness by avoiding interference between base and meta-level code that occur in more common reflective intercession mechanisms.},
	Address = {New York, NY, USA},
	Author = {Van Cutsem, Tom and Miller, Mark S.},
	Citeulike-Article-Id = {9886030},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=1869638},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/1899661.1869638},
	Date-Added = {2013-12-04 16:52:41 +0000},
	Date-Modified = {2013-12-04 16:52:41 +0000},
	Doi = {10.1145/1899661.1869638},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = oct,
	Pages = {59--72},
	Posted-At = {2011-10-10 12:11:46},
	Priority = {2},
	Publisher = {ACM},
	Title = {Proxies: design principles for robust object-oriented intercession {APIs}},
	Url = {http://dx.doi.org/10.1145/1899661.1869638},
	Volume = {45},
	Year = {2010},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QXi4uLy4uL3BhcGVyL1Zhbi0xMGEgUHJveGllcyBkZXNpZ24gcHJpbmNpcGxlcyBmb3Igcm9idXN0IG9iamVjdC1vcmllbnRlZCBpbnRlcmNlc3Npb24gQVBJcy5wZGbSFwsYGVdOUy5kYXRhTxECmAAAAAACmAACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH1Zhbi0xMGEgUHJveGllcyBkZXNpZyNCRDQ5RC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL1J3LDmYwAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADLDlggAAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAVmFuLTEwYSBQcm94aWVzIGRlc2lnI0JENDlELnBkZgAADgCmAFIAVgBhAG4ALQAxADAAYQAgAFAAcgBvAHgAaQBlAHMAIABkAGUAcwBpAGcAbgAgAHAAcgBpAG4AYwBpAHAAbABlAHMAIABmAG8AcgAgAHIAbwBiAHUAcwB0ACAAbwBiAGoAZQBjAHQALQBvAHIAaQBlAG4AdABlAGQAIABpAG4AdABlAHIAYwBlAHMAcwBpAG8AbgAgAEEAUABJAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAH9Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9WYW4tMTBhIFByb3hpZXMgZGVzaWduIHByaW5jaXBsZXMgZm9yIHJvYnVzdCBvYmplY3Qtb3JpZW50ZWQgaW50ZXJjZXNzaW9uIEFQSXMucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAO8A9AD8A5gDmgOfA6oDswPBA8UDzAPVA9oD5wPqA/wD/wQEAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAY=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1899661.1869638}}

@article{Cham89a,
	Abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.   To compensate for the absence of classes, our system uses implementation-level  maps  to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles  multiple versions  of a source method, each  customized  according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and  inline  all messages sent to self.  Message splitting  and  type prediction  extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.   Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.},
	Address = {New York, NY, USA},
	Author = {Chambers, C. and Ungar, D. and Lee, E.},
	Citeulike-Article-Id = {556549},
	Citeulike-Linkout-0 = {http://portal.acm.org/citation.cfm?id=74878.74884},
	Citeulike-Linkout-1 = {http://dx.doi.org/10.1145/74878.74884},
	Date-Added = {2013-12-04 16:52:26 +0000},
	Date-Modified = {2013-12-04 16:52:26 +0000},
	Doi = {10.1145/74878.74884},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Month = {October},
	Number = {10},
	Pages = {49--70},
	Posted-At = {2010-08-19 07:48:13},
	Priority = {2},
	Publisher = {ACM},
	Title = {An efficient implementation of {SELF} a dynamically-typed object-oriented language based on prototypes},
	Url = {http://dx.doi.org/10.1145/74878.74884},
	Volume = {24},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QfC4uLy4uL3BhcGVyL0NoYW04OWEgQW4gZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIFNFTEYgYSBkeW5hbWljYWxseS10eXBlZCBvYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2UgYmFzZWQgb24gcHJvdG90eXBlcy5wZGbSFwsYGVdOUy5kYXRhTxEC8gAAAAAC8gACAAAPU2Ftc3VuZyBTU0QgODQwAAAAAAAAAAAAAAAAz2HXFEgrAAAAC86bH0NoYW04OWEgQW4gZWZmaWNpZW50ICNCRDAwMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0AHIkgqYAAAAAAAAAAAAAgACAAAJIAAAAAAAAAAAAAAAAAAAAAVwYXBlcgAAEAAIAADPYbr0AAAAEQAIAADIke54AAAAAQAUAAvOmwAGKDAABiS/AAYkggACZa8AAgBhU2Ftc3VuZyBTU0QgODQwOlVzZXJzOgBjYW1pbGxvYnJ1bmk6AERvY3VtZW50czoAZWR1Y2F0aW9uOgBwYXBlcjoAQ2hhbTg5YSBBbiBlZmZpY2llbnQgI0JEMDAxLnBkZgAADgDiAHAAQwBoAGEAbQA4ADkAYQAgAEEAbgAgAGUAZgBmAGkAYwBpAGUAbgB0ACAAaQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuACAAbwBmACAAUwBFAEwARgAgAGEAIABkAHkAbgBhAG0AaQBjAGEAbABsAHkALQB0AHkAcABlAGQAIABvAGIAagBlAGMAdAAtAG8AcgBpAGUAbgB0AGUAZAAgAGwAYQBuAGcAdQBhAGcAZQAgAGIAYQBzAGUAZAAgAG8AbgAgAHAAcgBvAHQAbwB0AHkAcABlAHMALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAJ1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9DaGFtODlhIEFuIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBTRUxGIGEgZHluYW1pY2FsbHktdHlwZWQgb2JqZWN0LW9yaWVudGVkIGxhbmd1YWdlIGJhc2VkIG9uIHByb3RvdHlwZXMucGRmAAATAAEvAAAVAAIAE///AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAQ0BEgEaBBAEEgQXBCIEKwQ5BD0ERARNBFIEXwRiBHQEdwR8AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABH4=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/74878.74884}}

@book{Blac09a,
	Abstract = {Pharo by Example, intended for both students and
                  developers, will guide you gently through the Pharo
                  language and environment by means of a series of
                  examples and exercises. This book is made available
                  under the Creative Commons Attribution-ShareAlike
                  3.0 license.},
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {book},
	Author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Date-Added = {2013-12-04 16:52:19 +0000},
	Date-Modified = {2013-12-04 16:52:19 +0000},
	Inria = {ADAM},
	Isbn = {978-3-9523341-4-0},
	Keywords = {olit scg09 scg-pub jb09 snf-none skip-doi},
	Medium = {2},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {{Pharo} by Example},
	Url = {http://pharobyexample.org},
	Year = {2009},
	Bdsk-Url-1 = {http://pharobyexample.org}}

@electronic{Mira99a,
	Abstract = {Smalltalk-80 provides a reification of execution state in the form of context objects which represent procedure activation records. Smalltalk-80 also provides full closures with indefinite extent. These features pose interesting implementation challenges because a na\"{i}ve implementation entails instantiating context objects on every method activation, but typical Smalltalk-80 programs obey stack discipline for the vast majority of activations. Both software and hardware implementations of Smalltalk-80 have mapped contexts and closure activations to stack frames but not without overhead when compared to traditional stack-based activation and return in  '' conventional '' languages. We present a new design for contexts and closures that significantly reduces the overall overhead of these features and imposes overhead only in code that actually manipulates execution state in the form of contexts.},
	Author = {Miranda, Eliot},
	Citeulike-Article-Id = {7652821},
	Citeulike-Linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597},
	Date-Added = {2013-12-04 16:51:39 +0000},
	Date-Modified = {2013-12-04 16:51:39 +0000},
	Doi = {10.1.1.42.6597},
	Posted-At = {2010-08-15 15:25:36},
	Priority = {2},
	Title = {Context Management in {VisualWorks} 5i},
	Url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597},
	Year = {1999},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QPC4uLy4uL3BhcGVyL01pcmE5OWEgQ29udGV4dCBNYW5hZ2VtZW50IGluIFZpc3VhbFdvcmtzIDVpLnBkZtIXCxgZV05TLmRhdGFPEQIyAAAAAAIyAAIAAA9TYW1zdW5nIFNTRCA4NDAAAAAAAAAAAAAAAADPYdcUSCsAAAALzpsfTWlyYTk5YSBDb250ZXh0IE1hbmFnI0JEMTczLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvRc8g7o54AAAAAAAAAAAACAAIAAAkgAAAAAAAAAAAAAAAAAAAABXBhcGVyAAAQAAgAAM9huvQAAAARAAgAAMg7h34AAAABABQAC86bAAYoMAAGJL8ABiSCAAJlrwACAGFTYW1zdW5nIFNTRCA4NDA6VXNlcnM6AGNhbWlsbG9icnVuaToARG9jdW1lbnRzOgBlZHVjYXRpb246AHBhcGVyOgBNaXJhOTlhIENvbnRleHQgTWFuYWcjQkQxNzMucGRmAAAOAGIAMABNAGkAcgBhADkAOQBhACAAQwBvAG4AdABlAHgAdAAgAE0AYQBuAGEAZwBlAG0AZQBuAHQAIABpAG4AIABWAGkAcwB1AGEAbABXAG8AcgBrAHMAIAA1AGkALgBwAGQAZgAPACAADwBTAGEAbQBzAHUAbgBnACAAUwBTAEQAIAA4ADQAMAASAF1Vc2Vycy9jYW1pbGxvYnJ1bmkvRG9jdW1lbnRzL2VkdWNhdGlvbi9wYXBlci9NaXJhOTlhIENvbnRleHQgTWFuYWdlbWVudCBpbiBWaXN1YWxXb3JrcyA1aS5wZGYAABMAAS8AABUAAgAT//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AzQDSANoDEAMSAxcDIgMrAzkDPQNEA00DUgNfA2IDdAN3A3wAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADfg==},
	Bdsk-Url-1 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6597}}

@book{Kicz91a,
	Author = {Gregor Kiczales and Jim des Rivi\`eres and Daniel G. Bobrow},
	Isbn = {0-262-11158-6},
	Publisher = {MIT Press},
	Title = {The Art of the Metaobject Protocol},
	Year = {1991}}

@inproceedings{Vran12a,
	Abstract = {Programming languages are still evolving, and
                   programming languages and language features are being
                   designed and implemented every year. Since it is not
                   a trivial task to provide a runtime system for a new
                   language, existing runtime systems such as the Java
                   Virtual Machine or the Common Language Runtime are
                   used to host the new language. However, most of the
                   high-performance runtime systems were designed for a
                   specific language with a specific semantics.
                   Therefore, if the new language semantics differs from
                   the semantics hard-coded in a runtime system, it has
                   to be emulated on top of features supported by the
                   runtime. The emulation causes performance overhead.
                   To overcome the limitations of an emulation, a
                   runtime system may provide a meta-object protocol to
                   alter the runtime semantics. The protocol should
                   fulfill opposing goals: it should be flexible, easy
                   to use, fast and easy to implement at the same time.
                   We propose a simple meta-object protocol for
                   customization of a method lookup in Smalltalk. A
                   programmer may define his own custom method lookup
                   routine in Smalltalk and let the runtime system to
                   call it when needed. Therefore there is no need to
                   modify the runtime system itself. Our solution
                   provides reasonable performance thanks to low-level
                   support in a runtime system, nevertheless the changes
                   to the runtime system are small and local. At the
                   same time, it provides the flexibility to implement a
                   wide range of features present in modern programming
                   languages. The presented approach has been
                   implemented and validated on a Smalltalk virtual
                   machine.},
	Address = {Berlin, Heidelberg},
	Author = {Vran\'{y}, Jan and Kur\v{s}, Jan and Gittinger, Claus},
	Booktitle = {Proceedings of the 50th international conference on Objects, Models, Components, Patterns},
	Doi = {10.1007/978-3-642-30561-0\_10},
	Isbn = {978-3-642-30560-3},
	Pages = {124--139},
	Publisher = {Springer-Verlag},
	Series = {TOOLS'12},
	Title = {Efficient method lookup customization for {Smalltalk}},
	Url = {http://dx.doi.org/10.1007/978-3-642-30561-0\_10},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-642-30561-0%5C_10}}

@inproceedings{Fram09a,
	Abstract = {The power of high-level languages lies in their
                   abstraction over hardware and software complexity,
                   leading to greater security, better reliability, and
                   lower development costs. However, opaque abstractions
                   are often show-stoppers for systems programmers,
                   forcing them to either break the abstraction, or more
                   often, simply give up and use a different language.
                   This paper addresses the challenge of opening up a
                   high-level language to allow practical low-level
                   programming without forsaking integrity or
                   performance. The contribution of this paper is
                   three-fold: 1) we draw together common threads in a
                   diverse literature, 2) we identify a framework for
                   extending high-level languages for low-level
                   programming, and 3) we show the power of this
                   approach through concrete case studies. Our framework
                   leverages just three core ideas: extending semantics
                   via intrinsic methods, extending types via unboxing
                   and architectural-width primitives, and controlling
                   semantics via scoped semantic regimes. We develop
                   these ideas through the context of a rich literature
                   and substantial practical experience. We show that
                   they provide the power necessary to implement
                   substantial artifacts such as a high-performance
                   virtual machine, while preserving the software
                   engineering benefits of the host language. The time
                   has come for high-level low-level programming to be
                   taken more seriously: 1) more projects now use
                   high-level languages for systems programming, 2)
                   increasing architectural heterogeneity and
                   parallelism heighten the need for abstraction, and 3)
                   a new generation of high-level languages are under
                   development and ripe to be influenced.},
	Address = {New York, NY, USA},
	Author = {Frampton, Daniel and Blackburn, Stephen M. and Cheng, Perry and Garner, Robin J. and Grove, David and Eliot and Salishev, Sergey I.},
	Booktitle = {Proceedings of the 2009 ACM SIGPLAN/SIGOPS international conference on Virtual execution environments},
	Doi = {10.1145/1508293.1508305},
	Isbn = {978-1-60558-375-4},
	Pages = {81--90},
	Publisher = {ACM},
	Series = {VEE '09},
	Title = {Demystifying magic: high-level low-level programming},
	Url = {http://dx.doi.org/10.1145/1508293.1508305},
	Year = {2009},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/1508293.1508305}}

@inproceedings{Alpe99a,
	Abstract = {Jalape\~{n}o is a virtual machine for
                   Java{\texttrademark} servers written in {Java.A}
                   running Java program involves four layers of
                   functionality: the user code, the virtual-machine,
                   the operating system, and the hardware. By drawing
                   the Java / {non-Java} boundary below the virtual
                   machine rather than above it, Jalape\~{n}o reduces
                   the boundary-crossing overhead and opens up more
                   opportunities for {optimization.To} get Jalape\~{n}o
                   started, a boot image of a working Jalape\~{n}o
                   virtual machine is concocted and written to a file.
                   Later, this file can be loaded into memory and
                   executed. Because the boot image consists entirely of
                   Java objects, it can be concocted by a Java program
                   that runs in any {JVM}. This program uses reflection
                   to convert the boot image into Jalape\~{n}o's object
                   {format.A} special {MAGIC} class allows unsafe casts
                   and direct access to the hardware. Methods of this
                   class are recognized by Jalape\~{n}o's three
                   compilers, which ignore their bytecodes and emit
                   special-purpose machine code. User code will not be
                   allowed to call {MAGIC} methods so Java's integrity
                   is {preserved.A} small {non-Java} program is used to
                   start up a boot image and as an interface to the
                   operating {system.Java}'s programming features ---
                   object orientation, type safety, automatic memory
                   management --- greatly facilitated development of
                   Jalape\~{n}o. However, we also discovered some of the
                   language's limitations.},
	Address = {New York, NY, USA},
	Author = {Alpern, Bowen and Attanasio, C. R. and Cocchi, Anthony and Lieber, Derek and Smith, Stephen and Ngo, Ton and Barton, John J. and Hummel, Susan F. and Sheperd, Janice C. and Mergen, Mark},
	Booktitle = {Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Doi = {10.1145/320384.320418},
	Isbn = {1-58113-238-7},
	Pages = {314--324},
	Publisher = {ACM},
	Series = {OOPSLA '99},
	Title = {Implementing {Jalape{\~n}o} in {Java}},
	Url = {http://dx.doi.org/10.1145/320384.320418},
	Year = {1999},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/320384.320418}}

@inproceedings{Maes87a,
	Author = {Pattie Maes},
	Booktitle = {Proceedings OOPSLA '87, ACM SIGPLAN Notices},
	Doi = {10.1145/38765.38821},
	Month = dec,
	Pages = {147--155},
	Title = {Concepts and Experiments in Computational Reflection},
	Volume = {22},
	Year = {1987},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/38765.38821}}

@inproceedings{Inga97a,
	Author = {Ingalls, Dan and Kaehler, Ted and Maloney, John and Wallace, Scott and Kay, Alan},
	Booktitle = {OOPSLA'97: Proceedings of the 12th International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
	Doi = {10.1145/263700.263754},
	Month = nov,
	Pages = {318--326},
	Publisher = {ACM Press},
	Title = {Back to the Future: The Story of {Squeak}, a Practical {Smalltalk} Written in Itself},
	Url = {http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/ squeak.html},
	Year = {1997},
	Bdsk-Url-1 = {http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/%20squeak.html},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/263700.263754}}

@inproceedings{Mira11a,
	Author = {Eliot Miranda},
	Booktitle = {VMIL '11: Proceedings of the 5th workshop on Virtual machines and intermediate languages for emerging modularization mechanisms},
	Publisher = {ACM},
	Title = {The {Cog} {Smalltalk} Virtual Machine},
	Year = {2011}}

@inproceedings{Brun13a,
	Abstract = {{Foreign-Function-Interfaces (FFIs) are a
                   prerequisite for close system integration of a
                   high-level language. With FFIs the high-level
                   environment interacts with low-level functions
                   allowing for a unique combination of features. This
                   duality has a strong impact on the implementation of
                   the FFI: it has to be flexible and fast at the same
                   time. We propose NativeBoost a language-side approach
                   to FFIs that only requires minimal changes to the VM.
                   NativeBoost directly creates specific native code at
                   language-side and thus combines the flexibility of a
                   language-side library with the performance of a
                   native plugin.}},
	Address = {Annecy, France},
	Author = {Bruni, Camillo and Ducasse, St{\'e}phane and Stasenko, Igor and Fabresse, Luc},
	Booktitle = {{International Workshop on Smalltalk Technologies}},
	Language = {Anglais},
	Month = sep,
	Title = {{Language-side Foreign Function Interfaces with NativeBoost}},
	Url = {http://hal.inria.fr/hal-00840781},
	Year = {2013},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00840781}}

@inproceedings{Denk10a,
	Abstract = {A feature represents a functional requirement
                   fulfilled by a system. Since many maintenance tasks
                   are expressed in terms of features, it is important
                   to establish the correspondence between a feature and
                   its implementation in source code. Traditional
                   approaches to establish this correspondence exercise
                   features to generate a trace of runtime events, which
                   is then processed by post-mortem analysis. These
                   approaches typically generate large amounts of data
                   to analyze. Due to their static nature, these
                   approaches do not support incremental and interactive
                   analysis of features. We propose a radically
                   different approach called live feature analysis,
                   which provides a model at runtime of features. Our
                   approach analyzes features on a running system and
                   also makes it possible to grow feature
                   representations by exercising different scenarios of
                   the same feature, and identifies execution elements
                   even to the sub-method level. We describe how live
                   feature analysis is implemented effectively by
                   annotating structural representations of code based
                   on abstract syntax trees. We illustrate our live
                   analysis with a case study where we achieve a more
                   complete feature representation by exercising and
                   merging variants of feature behavior and demonstrate
                   the efficiency or our technique with benchmarks.},
	Author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of MODELS 2010 Part II},
	Doi = {10.1007/978-3-642-16129-2\_11},
	Isbn = {978-3-642-16128-5},
	Month = oct,
	Pages = {138--152},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Modeling Features at Runtime},
	Url = {http://rmod.lille.inria.fr/archives/papers/ Denk10a-Models10-FeatureModels.pdf},
	Volume = {6395},
	Year = {2010},
	Bdsk-Url-1 = {http://rmod.lille.inria.fr/archives/papers/%20Denk10a-Models10-FeatureModels.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-16129-2%5C_11}}

@unpublished{Char13a,
	Abstract = {{Modern languages are typically supported by managed
                   runtimes (Virtual Machines). Since VMs have to deal
                   with many concepts such as memory management,
                   abstract execution model and scheduling, they tend to
                   be very complex. Additionally, VMs have to meet
                   strong performance requirements. This demand of
                   performance is one of the main reasons why many VMs
                   are built statically. Thus, design decisions are
                   frozen at compile time preventing changes at runtime.
                   One clear example is the impossibility to dynamically
                   adapt or change primitives of the VM once it has been
                   compiled. In this work we present a toolchain that
                   allows for altering and configuring components such
                   as primitives and plug-ins at runtime. The main
                   contribution is Waterfall, a dynamic and reflective
                   translator from Slang, a restricted subset of
                   Smalltalk, to native code. Waterfall generates
                   primitives on demand and executes them on the fly. We
                   validate our approach by implementing dynamic
                   primitive modification and runtime customization of
                   VM plug-ins.}},
	Author = {Chari, Guido and Garbervetsky, Diego and Bruni, Camillo and Denker, Marcus and Ducasse, St{\'e}phane},
	Language = {English},
	Month = {Sep},
	Note = {Preprint: \url{http://hal.inria.fr/hal-00871353}},
	Title = {{Waterfall: Primitives Generation on the Fly}},
	Url = {http://hal.inria.fr/hal-00871353},
	Year = {2013},
	Bdsk-Url-1 = {http://hal.inria.fr/hal-00871353}}

@book{Appe98a,
	Address = {New York, NY, USA},
	Author = {Appel, Andrew W.},
	Isbn = {0-521-58388-8},
	Publisher = {Cambridge University Press},
	Title = {Modern compiler implementation in {Java}},
	Year = {1998}}

@book{Gold83a,
	Address = {Reading, Mass.},
	Author = {Adele Goldberg and David Robson},
	Isbn = {0-201-13688-0},
	Month = may,
	Publisher = {Addison Wesley},
	Title = {{Smalltalk-80}: the Language and its Implementation},
	Url = {http://stephane.ducasse.free.fr/FreeBooks/BlueBook/ Bluebook.pdf},
	Year = {1983},
	Bdsk-Url-1 = {http://stephane.ducasse.free.fr/FreeBooks/BlueBook/%20Bluebook.pdf}}

@article{Ayco03a,
	Abstract = {Software systems have been using "just-in-time"
                   compilation (JIT) techniques since the 1960s.
                   Broadly, JIT compilation includes any translation
                   performed dynamically, after a program has started
                   execution. We examine the motivation behind JIT
                   compilation and constraints imposed on JIT
                   compilation systems, and present a classification
                   scheme for such systems. This classification emerges
                   as we survey forty years of JIT work, from
                   1960--2000.},
	Address = {New York, NY, USA},
	Author = {Aycock, John},
	Doi = {10.1145/857076.857077},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Month = {June},
	Number = {2},
	Pages = {97--113},
	Publisher = {ACM},
	Title = {A brief history of just-in-time},
	Url = {http://dx.doi.org/10.1145/857076.857077},
	Volume = {35},
	Year = {2003},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/857076.857077}}

@comment{BibDesk URL Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>URL</key>
		<string>file://localhost/Users/cami-data/education/paper/cami.bib</string>
		<key>group name</key>
		<string>cami.bib</string>
	</dict>
</array>
</plist>
}}
