\input{chapter-header.tex}
% ===========================================================================
\chapter{Background}
\chaplabel{background}
\minitoc
% ===========================================================================
\introduction
% ===========================================================================

% ===========================================================================
\newpage
\section{Reflection}
% ===========================================================================
\todo{Image 4 Quadrants of reflection}\\
\todo{Two major distinctions (How): instropection / intercession}\\
\todo{Several dinstions (When/Where): time / reference / stack}
% ---------------------------------------------------------------------------
\subsection{Introspection or Structural Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Structural Reflection}
\begin{stcode}{}
'abc' class.
\end{stcode}
\begin{stcode}{}
#Dictionary asClass methods.
\end{stcode}

\todo{mirrors}

% ---------------------------------------------------------------------------
\subsection{Intercession or Behavioral Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Behavioral Reflection}
\begin{stcode}{}
#Dictionary asClass perform: #new
\end{stcode}
\begin{stcode}{}
thisContext restartWithNewReceiver: Object new 
\end{stcode}

\begin{stcode}{}
MyProxy >> doesNotUnderstand: aMessage
	^ destination 
		perform: aMessage selector
		withArguments: aMessage arguments
\end{stcode}

\todo{Some people call aspects in this context, however only a minority of aspect languages/framworks are dynamic like \cite{Assa08a}}\\
\todo{Typically intercession stops at method-level: see ByteSurgeon for extended reflection down to the AST \cite{Denk06a}}

% ---------------------------------------------------------------------------
\subsection{Scoping Reflection: Partial Behavioral Reflection}
% ---------------------------------------------------------------------------
Reflection brings great power to a programming language.
However, especially behavioral reflection is linked to a significant overhead.
For instance the previous example of the reified execution context in \ST requires restricts the optimizations at \VM-level.
And more general, most reification comes at great costs \cite{Male96a}.
Hence already from a performance point of view it is natural to limit the scope of reflective behavior.
Even so structural reflection can pose an overhead it does not directly influence the evaluation.
For instance, using wrapped methods to alter execution has a wide-spread effect on the system.
Thus, there is also a motivation to limit the effect on evaluation introduced by reflection.
We will now discuss several axes along which we can limit the use of reflection.
%
\begin{description}
\item[Time:] Of course the most obvious axis is time itself.
	In the context of \ST, behavioral reflection implies that the reflective properties are accessed or modified dynamically.
	By dynamically adding or removing the reflective code we have time-delimited reflection.
	
\item[Type:] Another natural delimiter for reflection is the type of an object.
	Again, this is rather natural in terms of \ST reflection since the natural base to modify behavior are the compiled methods.
	Hence it is possible to use use method wrappers only on one class (and it subclasses) by installed modified methods.

\item[Stack:] A second interesting limitation axis is the stack.
	An example of that is the concept of tower of interpreters.
	During the development of \P an intermediate version of the \ST interpreter featured this special execution scheme \cite{Verw10a}.
	It allows the programmer to switch the current interpreter.
	This way an expression is evaluated with altered semantics.
	The solution presented in \P does not globally replace the interpreter but only for the given expression. 
	Hence once the expression returns, the modifications and the implied overhead are gone.

\item[Reference:] Starting from the concept of a proxy object we find another possibility to limit reflection by reference.
	Arnaud et al. describe a modified \PH runtime where the concept of a reference is fully reified as a so called handles \cite{Arna13a}.
	Handles allow programmers to install new behavior and even state on a single reference, without influencing the rest of the system.
	\todo{proper example: revokable reference... extending proxies}
\end{description}
%

\noindent Tanter et. al. describe \textsc{Reflex} \cite{Tant03a} a partial behavioral reflection system on top of \Java.
We see similar limitation mechanisms for the applications of aspects \cite{Kicz01a}, which in a certain way resembles intercession.
However, typically the systems using aspects have to prepared statically upfront with little means to change them at runtime.
Aspects can be used to globally modify a system and introduced code snippets in defined points, for instance before each method invocation.
Though they share an interesting concepts of limiting the introduced overhead using a pointcuts.
These are conditionals that are dynamically before evaluating aspects.

Both \textsc{Reflex} and aspects require the underlying system to be prepared upfront.
Unanticipated behavioral reflection is not directly possible.
Typically it is only possible to enable or disable the reflective features that have been prepared upfront.
RÃ¶thlisberger et al. propose \Gepetto a system \cite{Roet07b} that enables true unanticipated behavioral reflection on top of \ST.
\Gepetto provides a high-level \API to install behavior reflection.
\cb{more needed?}

% ---------------------------------------------------------------------------
\subsection{\VM-level Reflection}
% ---------------------------------------------------------------------------
The basic reflective features have to be provided by the underlying meta-level.
For high-level languages this is the \VM.
For instance, simple cases involve giving access to the class of an object or the possibility to reflectively invoke a method at runtime.
\PH for instance is a more complex case, where the \VM has to provide access to the current execution context for introspection and even modification.
The latter one has a significant influence on the underlying \VM architecture preventing certain low-level optimization which would shadow the access to certain context information.
What we see is that the meta-level enables reflection but usually is not reflective by its own.

Following the \ST principle that everything is an object one might assume that this also includes the \VM as it is already highly involved in supporting reflection.
Typically the \VM is implemented in C or C++ which have no reflection.
However, the \JIT is common exception as it has to interact dynamically with the language-side.
For instance the \JIT has to be aware of classes and the methods within.
And in dynamic system like \PH it has to be made aware of language-side changes to properly update the generated native code.
What we see is that the \JIT accesses structural information from the language-side.
However, the language-side is not capable to accessing \VM-level information.
The closest \VM interaction point typically is the bytecode generated at language-side and handed over to the \VM for execution.
Yet, this provides only a crude one-way interaction \cite{Kell12a}.

For highly reflective and dynamic languages like \PH we see a certain mismatch.
While it is possible to virtually change and modify everything at language-side we are locked out of the \VM.
One argument in favor of that is that the underlying \VM provides security by isolation.
This is true for a more static language which restricts the reflective power.
However, this is clearly not the case in \PH or \ST.
Since arbitrary code changes are possible at language-side the boundary level of the \VM seems arbitrary.
Going one step back we can see a certain evolution in reflection which we would like to extend down to the \VM.

\begin{figure}[h]
\centering
\includegraphics[scale=1.1]{vm-reflection-evolution}
\figlabel{vm-reflection-evolution}
\end{figure}
%

\begin{enumerate}[a), nolistsep]
\item \textbf{Language-side without reflection:} A language in this category requires a virtual machine to run but has no reflective properties.
	This includes early-stage languages such as the original Pascal-P system.
	Typically languages without reflection also lack the underlying \VM and are compiled directly to native code.
	\cb{thus they are one meta-level short of performing reflection}
	
\item \textbf{Language-side with limited reflection:}
	The next step is to support only certain static reflection.
	This might include structural reflection whose required information can be prepared upfront during the compilation phase.
	Such a system has no support for unanticipated reflection as there is no support from the \VM to dynamically reify concepts.
	A \VM with a \JIT in this category can perform strong optimizations and take full advantage of the runtime information.
	\cb{GO fits here? \Java only partially?}
	
\item \textbf{Language-side extended reflection:}
	The third category of high-level language runtimes has extended reflection with strong support from the underlying \VM.
	We put \PH, \ST implementations or \Self in this category of languages.
	The \VM supports complex reification of otherwise non-accessible concepts such as the stack.
	At this stage the \VM-level optimizations are a balance between restricting the supported language or sacrificing speed.
	
\item \textbf{Language-side access to the \VM:}
	The \VM support for reflection is highly extended compared to the previous category.
	Instead of a hidden property, certain \VM-level concepts are made explicitly accessible to the running language.
	Up to some extent this is similar to language-side structural reflection as the \VM only supports only a restricted interface which is defined at compile-time.
	In this category the language can only read (introspect) \VM properties.
	To our best knowledge there are no existing language-runtimes that fall into this category.

\item \textbf{Language-side modification of the \VM:}
	The previous category allows the language-side to safely read \VM-level properties.
	If we follow the same path as the language-side evolution of reflection the next step is to allow for self-modification.
	Such a language-runtime has a dynamic interface to change certain properties of the \VM.
	However, the \VM is still not fully reflective in the sense that not all \VM concepts are reified.
	This essentially limits the language-side to simple interactions and changes to the \VM itself.
	At this point the \VM can no longer guarantee safety by isolating the language-side from all the low-level details.
	Again no systems are known to fit in this category.
	
\item \textbf{Self-aware \VM:}
	We classify in the last category dynamic language-runtimes that have no longer a clear separation of \VM and language-side.
	The same reflective properties equally apply to language-side and the \VM.
	The way to achieve this is by flattening out the intermediate \VM and let the language-side directly control everything.
	Currently there are several research \VMs which can be classified as self-aware \VMs: The \P \VM \cite{Verw12a} is partially self-aware but in control of the underlying execution and the \Klein \VM is fully reflective \cite{Unga05a}. 
\end{enumerate}


\noindent From this overview of reflective evolution of high-level languages we see that there is only little research about self-aware \VMs or reflective \VMs.
In general high-level languages are built with a clear distinction of the language-side and the \VM.
However, with further reflective capabilities of the language-side we see that such a separation is no longer a guarantee for security.
In fact most security aspects have to be addressed already at language-side \cite{??}.
This we want to focus in this thesis on the reflective aspects of the \VM.


% ===========================================================================
\section{Open \VMs}
\seclabel{background-open-vms}
% ===========================================================================
\todo{Simple History of \VMs: static frames, high abstraction mismatch}\\
\todo{missign structural refleciton => go towards \VM frameworks} \\
\todo{At the same time hard requirements which can only be achieved with very low-level programming}\\

% ---------------------------------------------------------------------------
\subsection{Metacircular \VMs}
\seclabel{background-metacircular-vms}
% ---------------------------------------------------------------------------
\todo{Ultimate Goal: Run the \VM in the same language... what do we improve by that?}\\
\todo{  lesser abstraction mismatch, known tools, better debugging, faster development }\\
\todo{Image different approaches 2 axis: lanugage properties(absorbed / explicit), bootstrap (intermediate, direct)}

\paragraph{Language Property Synthesis}
\todo{Where does the implemented lanugage properties come from: managed vs. explicit}.
\todo{Eraly approaches like the \Squeak \VM have no absorption}\\
\todo{Typical \VM generation framweork, akak. facny C or C++ (mimics their final staticness while being more flexible during pre-compilation)}\\
\todo{\PyPy gives not direct access to the underlying \JIT implementation, plug and play}\\
\todo{Very high-level interface}\\
\todo{Truffle as extreme to that track: Interpreter implementation on \AST basis, not explicit bytecode interpreter (which would be typical in C)}

\paragraph{Bootstrap Process}
\todo{Early approaches use C as intermeditate representation}\\
\todo{Implies the whole GCC stack} \\
\todo{Hard to circumvent GCC's limitations => generate own native code} \\
\todo{Fluent transition from purely C based bootstrap, over C-kernel + native code to purely native code} 


% ---------------------------------------------------------------------------
\subsection{Compile-time Reified \VMs}
% ---------------------------------------------------------------------------

\subsubsection*{\Squeak \ST \VM}
\seclabel{background-squeak}
% ---------------------------------------------------------------------------
\todo{Does not absorb any properties} \\
\todo{\ST used as C template engine}

\WF is implemented in \PH which uses the \urlfootnote{\Cog \VM}{http://www.mirandabanda.org/cogblog/}, originating from the \Squeak \VM\cite{Inga97a}.
The \VM itself is written in a dialect of \ST called \Slang that is essentially limited to the functionality that can be expressed with standard C code.
\Slang serves for two purposes: a high-level C preprocessor, a interactive simulator of the \VM.
The first point has severe consequences.
\Slang basically has the same syntax as \ST but is semantically constrained to expressions that can be resolved statically at compilation or code generation time and are compatible with C.
Hence \Slang's semantics are closer to C than to \ST.
This fact is also visible in the simulator for the \VM.
If \Slang were \ST, separate parts of the \VM could be directly evaluated.
However, since \Slang is bound to C expressions, the simulator sets up a byte array as memory.
The simulated \VM then accesses this byte array as if it were the native memory.

In conclusion we see that the \PH \VM has an abstract representation of the \VM available for simulation.
This abstract representation is then used to generate C sources, already lowering the abstraction level.
After compiling the C sources the original representation of the \VM is not directly accessible anymore.
For instance, even debug symbols are usually stripped from the final binary for performance reasons.
Of course this implies that the \VM can not be changed nor directly inspected from language-side.


% ---------------------------------------------------------------------------
\subsubsection*{High-level low-level Programming in \Jikes with \MMTK}
\seclabel{background-jikes}
% ---------------------------------------------------------------------------
\todo{Image: Infrastructure Overview}

High-level low-level programming \cite{Fram09a} advocates using high-level languages for system programming.
Frampton et al. present a low-level framework packaged as \ttt{org.vmmagic}, which is used as system interface for Jikes, an experimental Java VM.
Additionally their framework is successfully used in a separate project, the memory management toolkit (\MMTK) \cite{Blac04a} which is used independently in several other projects.
The \ttt{org.vmmagic} package introduces highly controlled low-level interaction in a statically type context.
Methods have to be annotated to use low-level functionality. 

The \ttt{org.vmmagic} package is much more elaborate than \NB, notably their type system extensions allow for optimized interaction between several low-level methods.
\cb{do we need to list more what they do?}
However as we state in the introduction, it is tailored towards Java with static types.
Additionally the strong separation between low-level code and runtime does not allow for reflective extensions of the runtime.

% ---------------------------------------------------------------------------
\subsubsection*{\Maxine \Java \VM}
\seclabel{background-maxine}
% ---------------------------------------------------------------------------
\Maxine is a metacircular \Java \VM \cite{Wimm13a} focused on an efficient developer experience.
The \Maxine \VM stands out as it truly focuses on productivity and developer interaction.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
\Maxine provides and excellent navigation for generated native code by providing links back to language-side objects as well as other native code and symbols.

Compared to \Maxine, the \B infrastructure currently lacks the debugging tools which would enable a truly seamless interaction with the low-level world.
Namely, \B does not support low-level debugging and does not support facilities to inspect low-level native code directly.
However, \Maxine focuses on \Java, a language with inferior reflective capabilities compared to \PH.
Hence the live interaction with the \VM is only possible during the development phase and not exposed to the language-side.


\subsubsection*{\PyPy}
\seclabel{background-pypy}
% ---------------------------------------------------------------------------
\urlfootnote{\PyPy}{http://pypy.org/} is a \Python-based high-level \VM framework \cite{Rigo06a}.
\PyPy's major focus lies on an efficient metacircular \Python interpreter.
However, it has been successfully used to build \VMs for other languages including \ST \cite{Bolz08a}.
Interpreters are written in a type-inferable subset of \Python called \RPython.
The underlying \PyPy infrastructure implicitly provides memory management and \JIT compilation.

\paragraph{Provided \VM Features}
\PyPy follows a different approach from the previously presented \VM generation frameworks.
For instance, in Squeak and \Jikes the final \VM implementation is not much different from C or C++.
The programmer specifies all the components of the \VM explicitly, either by implementing them directly or using a provided library.
Compared to the more static C ans C++ these \VM generation frameworks make the compilation phase more tangible.
\ST in \Squeak or \Java in \Jikes or \Maxine fulfill the purpose of the template system in C++ or the restricted macro system in C.
For the explicit implementation part \PyPy is no different.
However, certain features for the final \VM are directly absorbed from the underlying \PyPy infrastructure.
For instance, the \JIT support or the \GC are not explicitly implemented but provided by the \PyPy framework itself.
This is a big difference to the other \VM frameworks as it allows programmers to write the \VM in a more high-level fashion.
For instance in \Squeak memory allocation, even for \VM-level objects, has to be handled in the same way as in C.
Whereas in \PyPy the garbage collection is left to the underlying infrastructure.

\paragraph{\RPython Interpretation}
At compile-time the interpretation stack for a newly implemented \VM on top of \PyPy looks as follows.
%
\begin{enumerate}
\item The final language runtime
\item The \VM written in \RPython
\item The \PyPy infrastructure (virtual compile-time \RPython interpreter)
\end{enumerate}
%
Unless in debug mode, the bottom-most layer is compiled away by exporting the \RPython sources to C.
However, before the C export step, all the compile-time reflection statements are evaluated and flattened away.
This approach allows \RPython \VMs to behave almost like standard \Python programs while still providing excellent performance in the final \VM binary.

\paragraph{High-level Tracing \JIT}
Much like the automatic memory management, \PyPy provides a tracing \JIT generator \cite{Bolz09a}.
By default the \VM programmer does not write an explicit \JIT in \PyPy.
Instead the \VM code is annotated to guide the underlying tracing \JIT generator.
This means a \VM compilation time a specific tracing \JIT is created for the given meta information.
As a result, the \JIT can track high-level loops in the final interpreted language.

\todo{in that sense maybe also add truffle}


% ---------------------------------------------------------------------------
\subsection{Runtime Reified \VMs}
\seclabel{background-reified-vms}
% ---------------------------------------------------------------------------

The \VMs presented so far have little or no self-awareness.
Typically the \VM generation frameworks only allow a high amount of reflection at \VM compile time.
This meta information is typically compiled away, similar to a C++-based \VM.
The \VM frameworks themselves behave like a static language on their own.
The final \VM artifact has no access to the underlying definition anymore.
Typically some structural meta information is available at runtime but not made available to the language running on top.

We are now going to present \VMs that behave significantly different.
These \VMs have direct control over the underlying infrastructure and most concepts
\cb{yadda yadda yadda}
\todo{need proper link from static VM to dynamic VM}\\
\todo{draw parallel to C (classical VM), vs C++ (Maxine / Jikes), Java (PyPy) vs someting like ST} \\
\todo{probably add table for comparison}\\
\todo{Proper separation \cite{Wimm12a} at compile time should make it easy to push it to dynamic/runtime}


% ------------------------------------------------------------------------------
\subsubsection*{\Pinocchio \VM}
\seclabel{background-pinocchio}

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\todo{no real distinction between \JIT and interpreter} \\
\todo{compiler directly generates native code} \\
\todo{simplified infrastructure} \\
\todo{lagnuage-side: lookup links back to language-side code with prefilled native code to avoid meta recursion}
\todo{missing reification for the layout (work in progress)} \\
\todo{missing reification for low-level \VM objects} \\
\todo{still used minimal C kernel for simplicity} \\
\todo{required gcc + linker for bootstrap}

% ------------------------------------------------------------------------------
\subsubsection*{\MIST a C-less \ST Implementation}
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.

% ------------------------------------------------------------------------------
\subsubsection*{\DwarfPython}

\todo{see \cite{Kell11a}}
\todo{History based on \Parathon + \Dwarf}\\
\todo{explain unified \VM runtime model}\\
\todo{language-runtime controls everything}\\
\todo{user for better low-level interaction}\\
\todo{shared infrastructure for \FFI callout generation}\\

% ------------------------------------------------------------------------------
\subsubsection*{\Klein \VM}
\seclabel{background-klein}
\urlfootnote{\Klein}{http://kleinvm.sourceforge.net/} is a metacircular \VM for the \Self programming language that has no separation into \VM and language \cite{Unga05a}.
The \VM is entirely written in \Self but takes the concept of metacircular beyond the compile-time.
For instance, unlike many other metacircular \VMs, including \Cog and \Squeak, \Klein does not use an intermediate low-level language to bootstrap the system.
It generates directly a binary image, much like the aforementioned \P or \MIST \VM.
However, it is important to note that the \VM-level structures and objects are not compiled away as it is usually the case.
Instead the \VM structures are represented as real \Self objects.
Hence the \Klein \VM supports true \VM-level reflection since there is only a single code base.

Additionally to the advances in reflection and metacircularity, \Klein focuses on fast compilation turnarounds to allow for a responsive development process.
Which is unlike the \Squeak \VM where a full \VM bootstrap takes a order of minutes on modern hardware.
\Klein also supports advanced mirror-based debugging tools to inspect and modify a remote \VM.

Development on the \Klein \VM seized in 2009 and left the \Klein \VM in fairly usable state.
However, up to now it lacks a proper \GC which essentially limits its real-world application.
Yet, it proved that it is possible and build a language-runtime without a proper separation of the language-side and the \VM or base-level.
From the literature presented about the \Klein project we see a strong focus on the improvements of the development tools.
The fact that the language-runtime allows \VM-level reflection to change the \VM dynamically is not directly mentioned in the literature.
While we see the practical limitations of changing the \VM at runtime we would like to open the doors to this new form of reflection.
\todo{reread paper}
\todo{Image: Infrastructure Overview}


\section{Tools Accessing the VM}
\todo{properly integrate into the rest}

\subsection*{\Quicktalk}
\Quicktalk \cite{Ball86a} follows a similar path as we do with Waterfall presented in \secref{waterfall}.
However Ballard et al. focus mostly on the performance aspect.
They achieve higher performance mostly by eliminating the bytecode dispatch overhead.
Additionally they type annotate the code for the primitive definitions to benefit from further optimizations.
\WF however, is a very lightweight approach that provides less optimization opportunities on a general code base.
\Quicktalk tries to compile generic \ST code, where Waterfall is mainly applied to single limited primitives.


\subsection*{\DTrace}
\cb{maybe remove the dtrace discussion from here and move it into the waterfall section and cite \cite{Cant04a} there}
\todo{see \cite{Cant04a}}


% ===========================================================================
\section{Problem 1: }
% ===========================================================================


% ===========================================================================
\section{Problem 2: }
% ===========================================================================


% ===========================================================================
\section{Problem 3: }
% ===========================================================================


% ===========================================================================
\section{Summary and Outlook}
% ===========================================================================

\todo{Intro + List again the problems} \\
\todo{Sync Chapter Outlook}


% =============================================================================
\input{chapter-footer.tex}