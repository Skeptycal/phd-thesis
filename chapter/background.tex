\input{chapter-header.tex}
% ===========================================================================
\chapter{Background}
\chaplabel{background}
\minitoc
% ===========================================================================
\introduction
% ===========================================================================

% ===========================================================================
\newpage
\section{Reflection}
% ===========================================================================
\todo{Image 4 Quadrants of reflection}
% ---------------------------------------------------------------------------
\subsection{Introspection or Structural Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Structural Reflection}

% ---------------------------------------------------------------------------
\subsection{Intercession or Behavioral Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Behavioral Reflection}

% ---------------------------------------------------------------------------
\subsection{Reflection Scope}
% ---------------------------------------------------------------------------
\todo{Reflective Scope: How long does the modificaton live?}\\
\todo{delimited by stack?}\\
\todo{by objects?}\\
\todo{see pointcuts}\\
\todo{Complex reflection might require\VM-level adaptions}\\
\todo{- See Dynamic Context of Erwann}\\
\todo{- See first-class links by Jena Baptise}

% ---------------------------------------------------------------------------
\subsection{\VM-level Reflection}
% ---------------------------------------------------------------------------
\todo{Mini example / introduction: \JIT}\\
\todo{limited interface, duplicated framework to allow for low-level access}\\
\todo{In General: \VM-level reflection does not exist, only compile-time reflection in \VM frameworks!}\\
\todo{The 4th Quadrant!}


% ===========================================================================
\section{Open \VMs}
\seclabel{background-open-vms}
% ===========================================================================
\todo{Simple History of \VMs: static frames, high abstraction mismatch}\\
\todo{missign structural refleciton => go towards \VM frameworks} \\
\todo{At the same time hard requirements which can only be achieved with very low-level programming}\\
\todo{Induced limitations of the bytecode separation: JVM limited inspection \cite{Kell12a}}

% ---------------------------------------------------------------------------
\subsection{Metacircular \VMs}
\seclabel{background-metacircular-vms}
% ---------------------------------------------------------------------------
\todo{Ultimate Goal: Run the \VM in the same language... what do we improve by that?}\\
\todo{  lesser abstraction mismatch, known tools, better debugging, faster development }\\
\todo{Image different approaches 2 axis: lanugage properties(absorbed / explicit), bootstrap (intermediate, direct)}

\paragraph{Language Property Synthesis}
\paragraph{Bootstrap Process}

% ---------------------------------------------------------------------------
\subsection{Compile-time Reified \VMs}
% ---------------------------------------------------------------------------
\paragraph{\PyPy}
\seclabel{background-pypy}
\todo{Image: Infrastructure Overview}

% ---------------------------------------------------------------------------
\paragraph{\Jikes}
\seclabel{background-jikes}
\todo{Image: Infrastructure Overview}

% ---------------------------------------------------------------------------
\paragraph{\Maxine}
\seclabel{background-maxine}
\Maxine is a metacircular \Java \VM \cite{Wimm13a} focused on an efficient developer experience.
The \Maxine \VM stands out as it truly focuses on productivity and developer interaction.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
\Maxine provides and excellent navigation for generated native code by providing links back to language-side objects as well as other native code and symbols.

Compared to \Maxine, the \B infrastructure currently lacks the debugging tools which would enable a truly seamless interaction with the low-level world.
Namely, \B does not support low-level debugging and does not support facilities to inspect low-level native code directly.
However, \Maxine focuses on \Java, a language with inferior reflective capabilities compared to \PH.
Hence the live interaction with the \VM is only possible during the development phase and not exposed to the language-side.


% ---------------------------------------------------------------------------
\paragraph{\Graal}
\seclabel{background-graal}

% ---------------------------------------------------------------------------
\subsection{Runtime Reified \VMs}
\seclabel{background-reified-vms}
% ---------------------------------------------------------------------------


% ------------------------------------------------------------------------------
\subsubsection*{\Pinocchio \VM}
\seclabel{background-pinocchio}

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\todo{no real distinction between \JIT and interpreter} \\
\todo{compiler directly generates native code} \\
\todo{simplified infrastructure} \\
\todo{lagnuage-side: lookup links back to language-side code with prefilled native code to avoid meta recursion}
\todo{missing reification for the layout (work in progress)} \\
\todo{missing reification for low-level \VM objects} \\
\todo{still used minimal C kernel for simplicity} \\
\todo{required gcc + linker for bootstrap}

% ------------------------------------------------------------------------------
\subsubsection*{\MIST a C-less \ST Implementation}
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.

% ------------------------------------------------------------------------------
\subsubsection*{\DwarfPython}

\todo{see \cite{Kell11a}}
\todo{History based on \Parathon + \Dwarf}\\
\todo{explain unified \VM runtime model}\\
\todo{language-runtime controls everything}\\
\todo{user for better low-level interaction}\\
\todo{shared infrastructure for \FFI callout generation}\\

% ------------------------------------------------------------------------------
\subsubsection*{\Klein \VM}
\seclabel{background-klein}
\urlfootnote{\Klein}{http://kleinvm.sourceforge.net/} is a metacircular \VM for the \Self programming language that has no separation into \VM and language \cite{Unga05a}.
The \VM is entirely written in \Self but takes the concept of metacircular beyond the compile-time.
For instance, unlike many other metacircular \VMs, including \Cog and \Squeak, \Klein does not use an intermediate low-level language to bootstrap the system.
It generates directly a binary image, much like the aforementioned \P or \MIST \VM.
However, it is important to note that the \VM-level structures and objects are not compiled away as it is usually the case.
Instead the \VM structures are represented as real \Self objects.
Hence the \Klein \VM supports true \VM-level reflection since there is only a single code base.

Additionally to the advances in reflection and metacircularity, \Klein focuses on fast compilation turnarounds to allow for a responsive development process.
Which is unlike the \Squeak \VM where a full \VM bootstrap takes a order of minutes on modern hardware.
\Klein also supports advanced mirror-based debugging tools to inspect and modify a remote \VM.

Development on the \Klein \VM seized in 2009 and left the \Klein \VM in fairly usable state.
However, up to now it lacks a proper \GC which essentially limits its real-world application.
Yet, it proved that it is possible and build a language-runtime without a proper separation of the language-side and the \VM or base-level.
From the literature presented about the \Klein project we see a strong focus on the improvements of the development tools.
The fact that the language-runtime allows \VM-level reflection to change the \VM dynamically is not directly mentioned in the literature.
While we see the practical limitations of changing the \VM at runtime we would like to open the doors to this new form of reflection.
\todo{reread paper}
\todo{Image: Infrastructure Overview}

% ===========================================================================
\section{Problem 1: }
% ===========================================================================


% ===========================================================================
\section{Problem 2: }
% ===========================================================================


% ===========================================================================
\section{Problem 3: }
% ===========================================================================


% ===========================================================================
\section{Summary and Outlook}
% ===========================================================================

\todo{Intro + List again the problems} \\
\todo{Sync Chapter Outlook}


% =============================================================================
\input{chapter-footer.tex}