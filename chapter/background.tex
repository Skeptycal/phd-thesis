\input{chapter-header.tex}
% ===========================================================================
\chapter{Background}
\chaplabel{background}
\minitoc
% ===========================================================================
\introduction
% ===========================================================================

% ===========================================================================
\newpage
\section{Reflection}
% ===========================================================================
\todo{Image 4 Quadrants of reflection}
% ---------------------------------------------------------------------------
\subsection{Introspection or Structural Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Structural Reflection}
\begin{stcode}{}
'abc' class.
\end{stcode}
\begin{stcode}{}
#Dictionary asClass methods.
\end{stcode}

\todo{mirrors}

% ---------------------------------------------------------------------------
\subsection{Intercession or Behavioral Reflection}
% ---------------------------------------------------------------------------
\todo{Code Example: Behavioral Reflection}
\begin{stcode}{}
#Dictionary asClass perform: #new
\end{stcode}
\begin{stcode}{}
thisContext restartWithNewReceiver: Object new 
\end{stcode}

\begin{stcode}{}
MyProxy >> doesNotUnderstand: aMessage
	^ destination 
		perform: aMessage selector
		withArguments: aMessage arguments
\end{stcode}

\todo{Typically intercession stops at method-level: see ByteSurgeon for extended reflection down to the AST \cite{Denk06a}}

% ---------------------------------------------------------------------------
\subsection{Reflection Scope}
% ---------------------------------------------------------------------------
\todo{Reflective Scope: How long does the modificaton live?}\\
\todo{Mostly interesting for persistend behavior reflection}\\
\todo{- delimited by time (implicit since we can add/remove reflection dynamically)}\\
\todo{- delimited by stack (interpreter)?}\\
\todo{- by objects type (typicall ST reflection)?}\\
\todo{- by reference...}\\
\todo{- see pointcuts}\\
\todo{explain solutions:}
\todo{- See Interpreter Stack by Toon}\\ 	
\todo{- See Dynamic Context of Erwann}\\
\todo{- See first-class links by Jean Baptise}

\todo{They have in common: Complex reflection might require\VM-level adaptions}\\


% ---------------------------------------------------------------------------
\subsection{\VM-level Reflection}
% ---------------------------------------------------------------------------
\todo{Typically limited to the reflection capabilities of C and C++}\\
\todo{VM Generation Frameworks change the picture: full reflection at compile-time}\\
\todo{The 4th Quadrant!}

\todo{Mini example / introduction: \JIT}\\
\begin{stcode}{}
VM gc addGCSpace: MyCustomGCSpace new.
\end{stcode}


% ===========================================================================
\section{Open \VMs}
\seclabel{background-open-vms}
% ===========================================================================
\todo{Simple History of \VMs: static frames, high abstraction mismatch}\\
\todo{missign structural refleciton => go towards \VM frameworks} \\
\todo{At the same time hard requirements which can only be achieved with very low-level programming}\\
\todo{Induced limitations of the bytecode separation: JVM limited inspection \cite{Kell12a}}

% ---------------------------------------------------------------------------
\subsection{Metacircular \VMs}
\seclabel{background-metacircular-vms}
% ---------------------------------------------------------------------------
\todo{Ultimate Goal: Run the \VM in the same language... what do we improve by that?}\\
\todo{  lesser abstraction mismatch, known tools, better debugging, faster development }\\
\todo{Image different approaches 2 axis: lanugage properties(absorbed / explicit), bootstrap (intermediate, direct)}

\paragraph{Language Property Synthesis}
\todo{Where does the implemented lanugage properties come from: managed vs. explicit}.
\todo{Eraly approaches like the \Squeak \VM have no absorption}\\
\todo{Typical \VM generation framweork, akak. facny C or C++ (mimics their final staticness while being more flexible during pre-compilation)}\\
\todo{\PyPy gives not direct access to the underlying \JIT implementation, plug and play}\\
\todo{Very high-level interface}\\
\todo{Truffle as extreme to that track: Interpreter implementation on \AST basis, not explicit bytecode interpreter (which would be typical in C)}

\paragraph{Bootstrap Process}
\todo{Early approaches use C as intermeditate representation}\\
\todo{Implies the whole GCC stack} \\
\todo{Hard to circumvent GCC's limitations => generate own native code} \\
\todo{Fluent transition from purely C based bootstrap, over C-kernel + native code to purely native code} 


% ---------------------------------------------------------------------------
\subsection{Compile-time Reified \VMs}
% ---------------------------------------------------------------------------
\subsubsection*{\Squeak \ST \VM}
\seclabel{background-squeak}
% ---------------------------------------------------------------------------
\todo{Does not absorb any properties} \\
\todo{\ST used as C template engine}

\WF is implemented in \PH which uses the \urlfootnote{\Cog \VM}{http://www.mirandabanda.org/cogblog/}, originating from the \Squeak \VM\cite{Inga97a}.
The \VM itself is written in a dialect of \ST called \Slang that is essentially limited to the functionality that can be expressed with standard C code.
\Slang serves for two purposes: a high-level C preprocessor, a interactive simulator of the \VM.
The first point has severe consequences.
\Slang basically has the same syntax as \ST but is semantically constrained to expressions that can be resolved statically at compilation or code generation time and are compatible with C.
Hence \Slang's semantics are closer to C than to \ST.
This fact is also visible in the simulator for the \VM.
If \Slang were \ST, separate parts of the \VM could be directly evaluated.
However, since \Slang is bound to C expressions, the simulator sets up a byte array as memory.
The simulated \VM then accesses this byte array as if it were the native memory.

In conclusion we see that the \PH \VM has an abstract representation of the \VM available for simulation.
This abstract representation is then used to generate C sources, already lowering the abstraction level.
After compiling the C sources the original representation of the \VM is not directly accessible anymore.
For instance, even debug symbols are usually stripped from the final binary for performance reasons.
Of course this implies that the \VM can not be changed nor directly inspected from language-side.


% ---------------------------------------------------------------------------
\subsubsection*{High-level low-level Programming in \Jikes with \MMTK}
\seclabel{background-jikes}
% ---------------------------------------------------------------------------
\todo{Image: Infrastructure Overview}

High-level low-level programming \cite{Fram09a} advocates using high-level languages for system programming.
Frampton et al. present a low-level framework packaged as \ttt{org.vmmagic}, which is used as system interface for Jikes, an experimental Java VM.
Additionally their framework is successfully used in a separate project, the memory management toolkit (\MMTK) \cite{Blac04a} which is used independently in several other projects.
The \ttt{org.vmmagic} package introduces highly controlled low-level interaction in a statically type context.
Methods have to be annotated to use low-level functionality. 

The \ttt{org.vmmagic} package is much more elaborate than \NB, notably their type system extensions allow for optimized interaction between several low-level methods.
\cb{do we need to list more what they do?}
However as we state in the introduction, it is tailored towards Java with static types.
Additionally the strong separation between low-level code and runtime does not allow for reflective extensions of the runtime.

% ---------------------------------------------------------------------------
\subsubsection*{\Maxine \Java \VM}
\seclabel{background-maxine}
% ---------------------------------------------------------------------------
\Maxine is a metacircular \Java \VM \cite{Wimm13a} focused on an efficient developer experience.
The \Maxine \VM stands out as it truly focuses on productivity and developer interaction.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
\Maxine provides and excellent navigation for generated native code by providing links back to language-side objects as well as other native code and symbols.

Compared to \Maxine, the \B infrastructure currently lacks the debugging tools which would enable a truly seamless interaction with the low-level world.
Namely, \B does not support low-level debugging and does not support facilities to inspect low-level native code directly.
However, \Maxine focuses on \Java, a language with inferior reflective capabilities compared to \PH.
Hence the live interaction with the \VM is only possible during the development phase and not exposed to the language-side.


\subsubsection*{\PyPy}
\seclabel{background-pypy}
% ---------------------------------------------------------------------------
\urlfootnote{\PyPy}{http://pypy.org/} is a \Python-based high-level \VM framework \cite{Rigo06a}.
\PyPy's major focus lies on an efficient metacircular \Python interpreter.
However, it has been successfully used to build \VMs for other languages including \ST \cite{Bolz08a}.
Interpreters are written in a type-inferable subset of \Python called \RPython.
The underlying \PyPy infrastructure implicitly provides memory management and \JIT compilation.

\paragraph{Provided \VM Features}
\PyPy follows a different approach from the previously presented \VM generation frameworks.
For instance, in Squeak and \Jikes the final \VM implementation is not much different from C or C++.
The programmer specifies all the components of the \VM explicitly, either by implementing them directly or using a provided library.
Compared to the more static C ans C++ these \VM generation frameworks make the compilation phase more tangible.
\ST in \Squeak or \Java in \Jikes or \Maxine fulfill the purpose of the template system in C++ or the restricted macro system in C.
For the explicit implementation part \PyPy is no different.
However, certain features for the final \VM are directly absorbed from the underlying \PyPy infrastructure.
For instance, the \JIT support or the \GC are not explicitly implemented but provided by the \PyPy framework itself.
This is a big difference to the other \VM frameworks as it allows programmers to write the \VM in a more high-level fashion.
For instance in \Squeak memory allocation, even for \VM-level objects, has to be handled in the same way as in C.
Whereas in \PyPy the garbage collection is left to the underlying infrastructure.

\paragraph{\RPython Interpretation}
At compile-time the interpretation stack for a newly implemented \VM on top of \PyPy looks as follows.
%
\begin{enumerate}
\item The final language runtime
\item The \VM written in \RPython
\item The \PyPy infrastructure (virtual compile-time \RPython interpreter)
\end{enumerate}
%
Unless in debug mode, the bottom-most layer is compiled away by exporting the \RPython sources to C.
However, before the C export step, all the compile-time reflection statements are evaluated and flattened away.
This approach allows \RPython \VMs to behave almost like standard \Python programs while still providing excellent performance in the final \VM binary.

\paragraph{High-level Tracing \JIT}
Much like the automatic memory management, \PyPy provides a tracing \JIT generator \cite{Bolz09a}.
By default the \VM programmer does not write an explicit \JIT in \PyPy.
Instead the \VM code is annotated to guide the underlying tracing \JIT generator.
This means a \VM compilation time a specific tracing \JIT is created for the given meta information.
As a result, the \JIT can track high-level loops in the final interpreted language.


% ---------------------------------------------------------------------------
\subsection{Runtime Reified \VMs}
\seclabel{background-reified-vms}
% ---------------------------------------------------------------------------

The \VMs presented so far have little or no self-awareness.
Typically the \VM generation frameworks only allow a high amount of reflection at \VM compile time.
This meta information is typically compiled away, similar to a C++-based \VM.
The \VM frameworks themselves behave like a static language on their own.
The final \VM artifact has no access to the underlying definition anymore.
Typically some structural meta information is available at runtime but not made available to the language running on top.

We are now going to present \VMs that behave significantly different.
These \VMs have direct control over the underlying infrastructure and most concepts
\cb{yadda yadda yadda}
\todo{need proper link from static VM to dynamic VM}\\
\todo{draw parallel to C (classical VM), vs C++ (Maxine / Jikes), Java (PyPy) vs someting like ST}


% ------------------------------------------------------------------------------
\subsubsection*{\Pinocchio \VM}
\seclabel{background-pinocchio}

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\todo{no real distinction between \JIT and interpreter} \\
\todo{compiler directly generates native code} \\
\todo{simplified infrastructure} \\
\todo{lagnuage-side: lookup links back to language-side code with prefilled native code to avoid meta recursion}
\todo{missing reification for the layout (work in progress)} \\
\todo{missing reification for low-level \VM objects} \\
\todo{still used minimal C kernel for simplicity} \\
\todo{required gcc + linker for bootstrap}

% ------------------------------------------------------------------------------
\subsubsection*{\MIST a C-less \ST Implementation}
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.

% ------------------------------------------------------------------------------
\subsubsection*{\DwarfPython}

\todo{see \cite{Kell11a}}
\todo{History based on \Parathon + \Dwarf}\\
\todo{explain unified \VM runtime model}\\
\todo{language-runtime controls everything}\\
\todo{user for better low-level interaction}\\
\todo{shared infrastructure for \FFI callout generation}\\

% ------------------------------------------------------------------------------
\subsubsection*{\Klein \VM}
\seclabel{background-klein}
\urlfootnote{\Klein}{http://kleinvm.sourceforge.net/} is a metacircular \VM for the \Self programming language that has no separation into \VM and language \cite{Unga05a}.
The \VM is entirely written in \Self but takes the concept of metacircular beyond the compile-time.
For instance, unlike many other metacircular \VMs, including \Cog and \Squeak, \Klein does not use an intermediate low-level language to bootstrap the system.
It generates directly a binary image, much like the aforementioned \P or \MIST \VM.
However, it is important to note that the \VM-level structures and objects are not compiled away as it is usually the case.
Instead the \VM structures are represented as real \Self objects.
Hence the \Klein \VM supports true \VM-level reflection since there is only a single code base.

Additionally to the advances in reflection and metacircularity, \Klein focuses on fast compilation turnarounds to allow for a responsive development process.
Which is unlike the \Squeak \VM where a full \VM bootstrap takes a order of minutes on modern hardware.
\Klein also supports advanced mirror-based debugging tools to inspect and modify a remote \VM.

Development on the \Klein \VM seized in 2009 and left the \Klein \VM in fairly usable state.
However, up to now it lacks a proper \GC which essentially limits its real-world application.
Yet, it proved that it is possible and build a language-runtime without a proper separation of the language-side and the \VM or base-level.
From the literature presented about the \Klein project we see a strong focus on the improvements of the development tools.
The fact that the language-runtime allows \VM-level reflection to change the \VM dynamically is not directly mentioned in the literature.
While we see the practical limitations of changing the \VM at runtime we would like to open the doors to this new form of reflection.
\todo{reread paper}
\todo{Image: Infrastructure Overview}


\section{Tools Accessing the VM}
\todo{properly integrate into the rest}

\subsection*{\Quicktalk}
\Quicktalk \cite{Ball86a} follows a similar path as we do with Waterfall presented in \secref{waterfall}.
However Ballard et al. focus mostly on the performance aspect.
They achieve higher performance mostly by eliminating the bytecode dispatch overhead.
Additionally they type annotate the code for the primitive definitions to benefit from further optimizations.
\WF however, is a very lightweight approach that provides less optimization opportunities on a general code base.
\Quicktalk tries to compile generic \ST code, where Waterfall is mainly applied to single limited primitives.


\subsection*{\DTrace}
\cb{maybe remove the dtrace discussion from here and move it into the waterfall section and cite \cite{Cant04a} there}
\todo{see \cite{Cant04a}}


% ===========================================================================
\section{Problem 1: }
% ===========================================================================


% ===========================================================================
\section{Problem 2: }
% ===========================================================================


% ===========================================================================
\section{Problem 3: }
% ===========================================================================


% ===========================================================================
\section{Summary and Outlook}
% ===========================================================================

\todo{Intro + List again the problems} \\
\todo{Sync Chapter Outlook}


% =============================================================================
\input{chapter-footer.tex}