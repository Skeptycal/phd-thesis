\input{chapter-header.tex}
% =============================================================================
\chapter{Future Work}
\chaplabel{future}
\minitoc
% =============================================================================
\introduction
% =============================================================================

In \chapref{background} we gave an overview of different concepts of reflection focusing on the main distinction between language-side and \VM-side reflection.
While language-side reflection is very well described in research and rather wide-spread in dynamic languages, the \VM-side counterpart is not.
Compile-time reflection is the center of many popular \VM generation frameworks, but they usually exclude the dynamic reflection aspect of the final binary.
Nevertheless, it is always possible to introspect (structural reflection) the \VM at a very basic level.
Additionally, there are tools like \DTrace which provide a simple way to instrument a binary with little prior setup required.
Thus a limited form of intercession is possible on the binary executable themselves.
However, this still does not make the internal structural information of the \VM accessible that were available at compilation time.
And the restrictions are even more severe when it comes to \VM-level intercession.
It is foreseen for languages to dynamically influe the underlying \VM.

In the course of this thesis we presented tools that try to enter the field of \VM-level reflection -- all based on \B, a common framework to activate native code from language-side.

\WF's dynamic primitives are a first step towards modifying \VM behavior from language-side in a rather controlled way.
By bringing the metacircular \VM sources alive in \PH we connect the former static definition to the running artifact.
Modification happen not by injecting basic native instructions but at high-level by modifying and dynamically compiling primitives.

In contrast to \WF we developed \NBJ, a \JIT compiler prototype, that moves the original \VM component to the language-side.
While \NBJ is defined as language-side compiler using familiar coding patterns, its interaction with the \VM is not clean.
Unlike the plugins and primitives defined by \WF the \JIT generates native code that is heavily depending on the low-level and internal execution model of the \VM.
Unlike \WF \NBJ requires a modified \VM to add a basic interface for manually injecting \JIT code.

In this chapter we present possible solutions and an early prototype \VM that addresses the limitations we encountered while developing \NB, the \B-based \FFI, \WF and \NBJ.
We start by listing possible improvements for the language-side part of the \B infrastructure such as providing a well-defined high-level intermediate format.
This will lead to a description of required \VM-level improvements to make applications such as \WF or \NBJ feasible outside a research context.


% =============================================================================
\section{Background and Related Work}
\seclabel{future-related-work}
\seclabel{future-background}
% =============================================================================
The improvements to the existing infrastructure \B and possible future work is influenced by two research projects we described already in detail in \secref{background-reified-vms}: the \P \VM and the \Klein \VM.
For this chapter we present a small summary of these two metacircular \VMs with the focus on two things: their own limitations compare to \B and their influence on improvements and future work.


% -----------------------------------------------------------------------------
\subsection{\P \VM}
% -----------------------------------------------------------------------------

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\paragraph{Missing C Independence:}
The second negative point of \P is its dependence from C.
During the course of the \P development we greatly reduced the quantity of C code.
However, for simplicity we relied on a small C Kernel for the complete bootstrap of the language.
Additionally some crucial primitives that required system calls were implemented in C.

% -----------------------------------------------------------------------------
\subsection{MIST: A C-less \ST Implementation}
% -----------------------------------------------------------------------------
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.


% -----------------------------------------------------------------------------
\subsection{\Klein \VM}
% -----------------------------------------------------------------------------
\todo{refer to \secref{background-klein}}\\
\todo{read again} \\
\todo{\VM and language written in the same language} \\
\todo{unified model for runtime and compile time} \\
\todo{\VM-level reflection since there is only a single code base}\\
\todo{Responsive developement: no C++ / C compilation wait process involved}\\
\todo{Cmopared to \B radical break with the existing system, no fluent development} \\
\todo{Even though \B is capable, \Klein is much more} \\
\todo{much less hard-coded \VM level objects} \\

\todo{Fancy Debugging}

% -----------------------------------------------------------------------------
\subsection{\Maxine \VM}
% -----------------------------------------------------------------------------
\todo{refer to \secref{background-maxine} \cite{Wimm13a}}\\
\todo{inspector overview} \\
\todo{fluent navigation from low-level code to high-level inspectors}

\Maxine is a metacircular \Java \VM focused on an efficient developer experience.
The \Maxine \VM stands out as it truly focuses on productivity and developer interaction.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
Compared to \Maxine, \WF currently lacks the debugging tools which would enable a truly seamless interaction with the low-level world.
However, \Maxine focuses on \Java, a language with inferior reflective capabilities compared to \PH.
Hence the live interaction with the \VM is only presented in the development phase and not exposed to the language-side.
\Maxine would be an excellent candidate to implement our approach for \Java.


% =============================================================================


% =============================================================================
%\newpage
\section{Language-side Improvements}
\seclabel{future-language}
% =============================================================================
In this section we present the suggestion for improvements related mostly tied to the language-side part of \B.
Most of the solutions have been presented in the separate chapters of \B in \secref{benzo-problems}, \NB \FFI in \secref{ffi-problems} and the \B application prototypes (\secref{validation-waterfall-problems} and \secref{validation-nabujito-problems}).

% -----------------------------------------------------------------------------
\subsection{Improved Domain Specific Inspectors}
% -----------------------------------------------------------------------------
Domain specific inspectors are important for an efficient development as we pointed out in \secref{reification-inspectors}.
Similar to the \JIT approach we have to optimize the frequent tasks during development and provide a seamless integration.
This becomes even more important when working with low-level code and data that does not come with existing first-class structures.
We noticed that using \B for \NBJ and \WF that it is more convenient to rely on an existing low-level text-based debugger such as \ttt{gdb} to inspect C-level structures.

We have seen excellent use of inspectors in the \VM development of the \Cog \VM itself.
The original simulator supports inspecting objects in simulated raw memory.
\Cog added additional inspectors including disassembled instructions for the \JIT development.
However, with the recent changes the advanced simulator does not yet run in \PH and requires attention.

Lately we have seen a very similar approach for the \Maxine research \VM \cite{Wimm13a}.
It provides excellent low-level debugging interaction, switching seamlessly between low-level assembler views and high-level object inspectors.
We believe that it is an imperative requirement for a \VM development \IDE to support customizable inspectors that span from high-level to low-level.
Even though existing C-focused \IDEs provide more and more support for integrated inspectors the \VM domain has different needs.
C inspectors are tailored towards fixed-sized objects whose types can be statically inferred.
Whereas, for \VMs we only have a handful types of object layouts and the real type is only implicitly available.
For instance in certain \VMs the class is encoded in the header of an object instead of a simple full pointer to the class object.
This means that a minor interpretation pass is necessary to retrieve such information.
Which is why most C-focused \IDEs are only partially sufficient for an efficient \VM development.


% -----------------------------------------------------------------------------
\subsection{Barrier-free Low-level Interaction}
% -----------------------------------------------------------------------------
Shifting from \VM development to the final language-runtime we see a similar issue when it comes to tools that span abstraction levels.
It is not directly possible to inspect low-level objects from language-side.
Focusing the on the \B architecture what comes closes to inspecting low-level objects is the \ttt{struct} support for the \NB \FFI library described in \secref{ffi-newtypes}.
We already use this approach for the \NBJ project to inspect \VM internal meta objects for debugging purposes.
It is important to note that giving access to the \VM internal objects is not permitted in most languages.
The previously mentioned \VM generation frameworks usually have first-class objects for all the \VM internal objects or provide mirror-like facilities to access objects from raw memory.
Usually, none of this structural information survives the \VM compilation phase.
Essentially this leaves the final \VM binary with little or no means for introspection. Of course the same restrictions apply then for language-side tools like \B that want to interact with the \VM internals.

\paragraph{Customized \VM \MOP}
We have seen in \secref{validation-nabujito-problems} for \NBJ that the only way to circumvent such issues is by creating modified \VMs which enable specific interaction points.
There are other \PH-based research projects \cite{??} that took the same path and created a modified \VM.
We, believe that with an extended low-level \MOP the focus for research projects could shift from the \VM to the language-side.
The final extreme is to have a system that works like the described \Klein \VM where there is no longer a clear distinction of what is \VM-level and what is language-side.

\paragraph{Anticipated Debugging}
For \B we have more modest intermediate goals.
The major drawback for a seamless developer experience is the lack of a dedicate low-level debugging infrastructure.
At this point, \B developers have to rely on 3rd-party C-centric tools for debugging.
Hence, a developer has to decide upfront at which abstraction level the debugging should occur.
Either at high-level without the possibility to deal with low-level errors, or at low-level losing all the inspection capabilities.
Besides the shortcomings that either side of the decision will bring, already the fact that the debugging direction has to be anticipated is inappropriate.

We outlined in \secref{benzo-problems-debugging} already several ways to improve the current debugging situation for \B.
The most important focus is on reducing the cases where the programmer has to anticipate the debugging tool.
Since we have to deal with two very distinct abstraction levels we can not only rely on a pure language-side solution to provide different debuggers \cite{Towards a Moldable Debugger}.
The major problem is the serious implications of a low-level error.
Unlike user-level errors they are not well-defined or even contained.
It is astonishingly simple to corrupt the \VM memory while writing low-level code and thus breaking any contract with the \VM code.
However, it is more common to access protected memory due to a wrongly dereferenced pointer.
Hence, the \B should focus on this most common bug by following the solution outlined in \figref{benzo-debugger}.
%
\begin{figure}[h]
	\centering
	\includegraphics[scale=\imagescale]{benzo-debugger}
	\caption{\B Debugger Outline}
	\figlabel{benzo-debugger}
\end{figure}
%
\begin{enumerate}
	\item Standard \PH method activating a \B-enabled method through the \ttt{primitiveNativeCall} primitive.
	\item Native code causing a memory access violation (for example \ttt{SIGSEV}) which can not be handled by \PH directly.
	\item Low-level signal handler is activated by the operating system and tries to walk back the native stack up to the \ttt{primitiveNativeCall} activation.
	\item After successfully finding the \ttt{primitiveNativeCall} the signal handler sends a \B failure back to \PH.
\end{enumerate}

\paragraph{Barrier-free Debugging}
After proposing a solution to improve \B's bug recovery behavior we immediately encounter a second problem.
How do we debug low-level code?
With the aforementioned solution we are able to recover from certain low-level errors and signal them properly at language-side.
In a \ST-like environment the debugger will pop up on the location causing the error and thus allowing a programmer to inspect stack and variables.
To provide the same facility for \B we have to plug into the existing low-level debugging utilities such as \ttt{ptrace} to enable stepping over native instructions.
The following \figref{benzo-crossover-debugger} outlines the basics of a debugger that crosses the high-level / low-level barrier.
%
\begin{figure}[h]
	\centering
	\includegraphics[scale=\imagescale]{benzo-crossover-debugger}
	\caption{\B Crossover Debugger Outline}
	\figlabel{benzo-crossover-debugger}
\end{figure}
%
\begin{enumerate}
	\item Point where a \B initiates a native call and the debugger switches from a high-level \PH stack to the low-level native stack.
To properly use low-level debugging tools we fork the complete \VM process.
	\item The low-level debugger in \PH switches the underlying debugging interface.
Instead of directly interacting with first-class \PH context we communicate to the the forked process with tools like \ttt{ptrace}.
	\item The forked process is updated according to the actions initiated from the \PH side.
\end{enumerate}

\noindent The outlined debugger will not work in certain cases where the native code directly interacts with the outer image.
The forked debugger process provides security from the main \PH image by isolating it.
However, for many \B applications such as the \FFI implementation this limitation would not apply.

\cb{more?}

% -----------------------------------------------------------------------------
\subsection{Virtual \CPU an Assembler \DSL}
% -----------------------------------------------------------------------------
\B uses \AsmJIT as assembler backend which is currently limited to x86 instruction set.
This choice is aligned with \PH main development branches for the most common operating systems.
However, this excludes mobile devices which currently focus on \ARM-based architectures.
To support this new architecture we have to extend the assembler backend in \AsmJIT.
The changes for \B-based applications such as the \NB \FFI are more severe.
Essentially most low-level code has to be replicated for each new platform.
A better solution is to use an intermediate format for all the low-level code which is then compiled for each platform specifically.

\todo{\ASM code is too low-level: \NB lacks expressiveness} \\
\todo{see \secref{benzo-problems-platform-independence}} \\
\todo{\ASM is hard to debug directly: very un \PH-ish, we need direct feedback}

\paragraph{A Low-level Intermediate Format}
\todo{change a bit to make the copy}
\VCPU is based on a \TAC to simplify the adoption of optimizations such as \SSA.
These \TAC instruction take the following form:
%
\begin{stcode}{}
result := argument1 OP argument2
\end{stcode}
%
There are three operands involved, \ttt{result}, \ttt{argument1} and \ttt{argument2}, from which the name of this instruction format originates.
Based on this assumption, each standard \VCPU instruction returns a temporary variable which can be used for further operations.
The following code example outlines the basic usage of \VCPU:
%
\begin{stcode}[
	label={lst:benzo-problem-vcpu}, 
	caption={Basic \VCPU Example}
]{}
Benzo vcpu x86 generate: [ :asm | | temp1 temp2 |
	temp1 := asm memoryAt: 16r12345.
	temp2 := asm uint: 2.
	asm return: temp1 + temp1 ]
\end{stcode}
%
Which corresponds to the same functionality expressed in the following x86 instructions:
%
\begin{stcode}{}
Benzo x86 generate: [ :asm |
	asm mov: 16r12345 ptr to: asm EAX.
	asm add: asm EAX with: 2.
	asm return ]
\end{stcode}

%%\todo{Design overview/flow figure with backends} \\
\todo{inject high-level instructions} \\
\todo{explain the difference to explicit code like \ASM by having a different backends}

\paragraph{\VCPU Testing and Debugging}
\todo{\VCPU interpreter} \\
\todo{tracer backend for code generation} \\
\todo{Native Simluator for the specific backends} \\
\todo{Requires mapping from native instruction to the \VCPU instructions}


\paragraph{\VCPU Optimizations}
\todo{Optimizations required for \B-based applications can be shared} \\

To get to the final native instructions the \VCPU infrastructure compiles the high-level instructions to the specific backend.
The current compiler is divided into the following passes:
%
\begin{itemize}[noitemsep]
\item Platform Specific Transformation
\item Register Allocation
\item Superfluous Assignment Remover
\item Platform Specific Assembler
\end{itemize}



\todo{Current State of the Implementation} \\
\todo{Support new Platforms} \\
\todo{Indirect support for simluation and thus better debugging}


% =============================================================================
\section{\VM-level Improvements}
\seclabel{future-vm}
% =============================================================================
\todo{Introduction: Lanugage-side is not enough} \\
\todo{Need to get a obstacle-free VM} \\
\todo{List of requirements for a new VM Infrastructure} \\ 
\todo{Small comparison against the current solution we have with COG} \\
\todo{Follow the \Klein approach}


% -----------------------------------------------------------------------------
\subsection{VM-level Reification}
% -----------------------------------------------------------------------------
\todo{Resulting from the first law of Inspectors, all VM-level objects are reified} \\
\todo{List of typical objects that don't have a reification in COG} \\
\todo{List advantages}\\
\todo{make concepts explicit and first-class} \\
\todo{limit the use of raw memory access and string-based programming} \\

% -----------------------------------------------------------------------------
\subsection{Runtime Reification / Dual Objects}
% -----------------------------------------------------------------------------
\todo{Reuse the same objects for the bootstrap and at runtime inspectors/mirrors} \\
\todo{goes further than the sheer compile-time reification} \\
\todo{accessible from language-side => leads to the following MOP}

% -----------------------------------------------------------------------------
\subsection{Mate Object Model and Runtime MOP}
% -----------------------------------------------------------------------------
\todo{consequence of the runtime reification of the VM introspection => intercession}\\
\todo{Rough Overview of all the Objects currently present in Mate (UMLish)}

% -----------------------------------------------------------------------------
\subsection{Be Native}
% -----------------------------------------------------------------------------
\todo{out of the intercession capabilities follows that we need native support at runtime (see \B)}\\
\todo{that means we need to have decent / better infrasrtucture for native code}\\
\todo{need to be able to achieve what \NBJ didn't manage: compile native methods and hand them over to the \VM}\\
\todo{step towards our implementation in \Mate}


% =============================================================================
\section{\Mate a Reflective \VM Prototype}
\seclabel{mate}
% =============================================================================

\begin{figure*}[h]
	\begin{adjustwidth}{-10.0in}{-10.0in}
		\centering
		\includegraphics[width=1.02\textwidth]{mate-logo}
	\end{adjustwidth}
\end{figure*}

\todo{introduction: protoype based on the conclusions presented in the previous sections}\\
\todo{for reasearch mainly but possible long term solution to our \VM problems}

% -----------------------------------------------------------------------------
\subsection{Mate Compiler Outline}
\seclabel{future-mate-compiler}
% -----------------------------------------------------------------------------
\todo{Small Intro: Reuse the bootstrap infrastrucutre at runtime (FFI, JIT...)}

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{mate-compilation-toolchain}
\end{figure}

% -----------------------------------------------------------------------------
\subsection{Mate Bootstrap Outline}
\todo{Small Intro: Why Bootstrap and how to use the reified objects}\\
\todo{Compare to Pinocchio (manual approach)}\\
\todo{Work in Progress: Envision the trace-based Bootstrap}


% -----------------------------------------------------------------------------
\subsection{Mate Towards Complete Reflection}
\todo{list possible paths between the 4 quadrants of reflection}\\
\todo{usecase: dynamic gc change}\\
\todo{usecase: dynamic object format influence}\\
\todo{usecase: optimize partial behavior reflection (immutability, proxies)}\\

% =============================================================================
\section{SISTA: Language-side Adaptive Recompilation}
% =============================================================================

\todo{do we put this in a separate section?}\\
\todo{related to \NBJ, but more real-world approach}

% =============================================================================
\section{Reflective Future}
% =============================================================================
% NEW concepts
\todo{Check with GUIDO} \\
\todo{List 3 to 4 different Examples entering the 4th quadrant:}

% -----------------------------------------------------------------------------
\subsection{Accessible VM Components}
% -----------------------------------------------------------------------------
\todo{Access GC Statistics} \\
\todo{Access JIT Statistics for Type Annotations / Tooling}

% -----------------------------------------------------------------------------
\subsection{Interchangeable VM Components}
% -----------------------------------------------------------------------------
\todo{Change GC strategy} \\
\todo{Change JIT Strategy}

% -----------------------------------------------------------------------------
\subsection{Interchangeable Language Semantics}
% -----------------------------------------------------------------------------
\todo{Up to which extent can this be supported?} \\
\todo{Related to VM MOP: How much should be changeable? When?}


% -----------------------------------------------------------------------------
\subsection{Efficient Reflection}
% -----------------------------------------------------------------------------
\todo{Reflectivity at VM-level} \\
\todo{Flatten but don't freeze Reflection/Abstraction}


% =============================================================================
\section{Summary}
% =============================================================================

\todo{a lot of work on the engineering level to get a \VM with reflective properties}\\
\todo{- limited resources focused on maintaining the current infrastructure} \\
\todo{for research we have already sufficient tools at hand to experiment} \\
\todo{- outline some stuff for guido} \\
\todo{possiblity to split up off tools to be used by \PH} \\
\todo{- VCPU IR} \\
\todo{- improved FFI}


% =============================================================================
\input{chapter-footer.tex}