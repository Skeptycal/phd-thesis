\input{chapter-header.tex}
% =============================================================================
\chapter{Future Work}
\chaplabel{future}
\minitoc
% =============================================================================
\introduction
% =============================================================================

In \chapref{background} we gave an overview of different concepts of reflection focusing on the main distinction between language-side and \VM-side reflection.
While language-side reflection is very well described in research and rather wide-spread in dynamic languages, the \VM-side counterpart is not.
Compile-time reflection is the center of many popular \VM generation frameworks, but they usually exclude the dynamic reflection aspect of the final binary.
Nevertheless, it is always possible to introspect (structural reflection) the \VM at a very basic level.
Additionally, there are tools like \DTrace which provide a simple way to instrument a binary with little prior setup required.
Thus a limited form of intercession is possible on the binary executable themselves.
However, this still does not make the internal structural information of the \VM accessible that were available at compilation time.
And the restrictions are even more severe when it comes to \VM-level intercession.
It is foreseen for languages to dynamically influe the underlying \VM.

In the course of this thesis we presented tools that try to enter the field of \VM-level reflection -- all based on \B, a common framework to activate native code from language-side.

\WF's dynamic primitives are a first step towards modifying \VM behavior from language-side in a rather controlled way.
By bringing the metacircular \VM sources alive in \PH we connect the former static definition to the running artifact.
Modification happen not by injecting basic native instructions but at high-level by modifying and dynamically compiling primitives.

In contrast to \WF we developed \NBJ, a \JIT compiler prototype, that moves the original \VM component to the language-side.
While \NBJ is defined as language-side compiler using familiar coding patterns, its interaction with the \VM is not clean.
Unlike the plugins and primitives defined by \WF the \JIT generates native code that is heavily depending on the low-level and internal execution model of the \VM.
Unlike \WF \NBJ requires a modified \VM to add a basic interface for manually injecting \JIT code.

In this chapter we present possible solutions and an early prototype \VM that addresses the limitations we encountered while developing \NB, the \B-based \FFI, \WF and \NBJ.
We start by listing possible improvements for the language-side part of the \B infrastructure such as providing a well-defined high-level intermediate format.
This will lead to a description of required \VM-level improvements to make applications such as \WF or \NBJ feasible outside a research context.


% =============================================================================
\section{Background and Related Work}
\seclabel{future-related-work}
\seclabel{future-background}
% =============================================================================
The improvements to the existing infrastructure \B and possible future work is influenced by two research projects we described already in detail in \secref{background-reified-vms}: the \P \VM and the \Klein \VM.
For this chapter we present a small summary of these two metacircular \VMs with the focus on two things: their own limitations compare to \B and their influence on improvements and future work.


% -----------------------------------------------------------------------------
\subsection{\P \VM}
% -----------------------------------------------------------------------------

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\paragraph{Missing C Independence:}
The second negative point of \P is its dependence from C.
During the course of the \P development we greatly reduced the quantity of C code.
However, for simplicity we relied on a small C Kernel for the complete bootstrap of the language.
Additionally some crucial primitives that required system calls were implemented in C.

% -----------------------------------------------------------------------------
\subsection{MIST: A C-less \ST Implementation}
% -----------------------------------------------------------------------------
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.


% -----------------------------------------------------------------------------
\subsection{\Maxine \VM}
% -----------------------------------------------------------------------------
\Maxine is a metacircular \Java \VM \cite{Wimm13a} focused on an efficient developer experience.
The \Maxine \VM stands out as it truly focuses on productivity and developer interaction.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
\Maxine provides and excellent navigation for generated native code by providing links back to language-side objects as well as other native code and symbols.

Compared to \Maxine, the \B infrastructure currently lacks the debugging tools which would enable a truly seamless interaction with the low-level world.
Namely, \B does not support low-level debugging and does not support facilities to inspect low-level native code directly.
However, \Maxine focuses on \Java, a language with inferior reflective capabilities compared to \PH.
Hence the live interaction with the \VM is only possible during the development phase and not exposed to the language-side.

% -----------------------------------------------------------------------------
\subsection{\Klein \VM}
% -----------------------------------------------------------------------------
\urlfootnote{\Klein}{http://kleinvm.sourceforge.net/} is a metacircular \VM for the \Self programming language that has no separation into \VM and language \cite{Unga05a}.
The \VM is entirely written in \Self but takes the concept of metacircular beyond the compile-time.
For instance, unlike many other metacircular \VMs, including \Cog and \Squeak, \Klein does not use an intermediate low-level language to bootstrap the system.
It generates directly a binary image, much like the aforementioned \P or \MIST \VM.
However, it is important to note that the \VM-level structures and objects are not compiled away as it is usually the case.
Instead the \VM structures are represented as real \Self objects.
Hence the \Klein \VM supports true \VM-level reflection since there is only a single code base.

Additionally to the advances in reflection and metacircularity, \Klein focuses on fast compilation turnarounds to allow for a responsive development process.
Which is unlike the \Squeak \VM where a full \VM bootstrap takes a order of minutes on modern hardware.
\Klein also supports advanced mirror-based debugging tools to inspect and modify a remote \VM.

Development on the \Klein \VM seized in 2009 and left the \Klein \VM in fairly usable state.
However, up to now it lacks a proper \GC which essentially limits its real-world application.
Yet, it proved that it is possible and build a language-runtime without a proper separation of the language-side and the \VM or base-level.
From the literature presented about the \Klein project we see a strong focus on the improvements of the development tools.
The fact that the language-runtime allows \VM-level reflection to change the \VM dynamically is not directly mentioned in the literature.
While we see the practical limitations of changing the \VM at runtime we would like to open the doors to this new form of reflection.

% =============================================================================


% =============================================================================
%\newpage
\section{Language-side Improvements}
\seclabel{future-language}
% =============================================================================
In this section we present the suggestion for improvements related mostly tied to the language-side part of \B.
Most of the solutions have been presented in the separate chapters of \B in \secref{benzo-problems}, \NB \FFI in \secref{ffi-problems} and the \B application prototypes (\secref{validation-waterfall-problems} and \secref{validation-nabujito-problems}).

% -----------------------------------------------------------------------------
\subsection{Improved Domain Specific Inspectors}
% -----------------------------------------------------------------------------
Domain specific inspectors are important for an efficient development as we pointed out in \secref{reification-inspectors}.
Similar to the \JIT approach we have to optimize the frequent tasks during development and provide a seamless integration.
This becomes even more important when working with low-level code and data that does not come with existing first-class structures.
We noticed that using \B for \NBJ and \WF that it is more convenient to rely on an existing low-level text-based debugger such as \ttt{gdb} to inspect C-level structures.

We have seen excellent use of inspectors in the \VM development of the \Cog \VM itself.
The original simulator supports inspecting objects in simulated raw memory.
\Cog added additional inspectors including disassembled instructions for the \JIT development.
However, with the recent changes the advanced simulator does not yet run in \PH and requires attention.

Lately we have seen a very similar approach for the \Maxine research \VM \cite{Wimm13a}.
It provides excellent low-level debugging interaction, switching seamlessly between low-level assembler views and high-level object inspectors.
We believe that it is an imperative requirement for a \VM development \IDE to support customizable inspectors that span from high-level to low-level.
Even though existing C-focused \IDEs provide more and more support for integrated inspectors the \VM domain has different needs.
C inspectors are tailored towards fixed-sized objects whose types can be statically inferred.
Whereas, for \VMs we only have a handful types of object layouts and the real type is only implicitly available.
For instance in certain \VMs the class is encoded in the header of an object instead of a simple full pointer to the class object.
This means that a minor interpretation pass is necessary to retrieve such information.
Which is why most C-focused \IDEs are only partially sufficient for an efficient \VM development.


% -----------------------------------------------------------------------------
\subsection{Barrier-free Low-level Interaction}
% -----------------------------------------------------------------------------
Shifting from \VM development to the final language-runtime we see a similar issue when it comes to tools that span abstraction levels.
It is not directly possible to inspect low-level objects from language-side.
Focusing the on the \B architecture what comes closes to inspecting low-level objects is the \ttt{struct} support for the \NB \FFI library described in \secref{ffi-newtypes}.
We already use this approach for the \NBJ project to inspect \VM internal meta objects for debugging purposes.
It is important to note that giving access to the \VM internal objects is not permitted in most languages.
The previously mentioned \VM generation frameworks usually have first-class objects for all the \VM internal objects or provide mirror-like facilities to access objects from raw memory.
Usually, none of this structural information survives the \VM compilation phase.
Essentially this leaves the final \VM binary with little or no means for introspection. Of course the same restrictions apply then for language-side tools like \B that want to interact with the \VM internals.

\paragraph{Customized \VM \MOP}
We have seen in \secref{validation-nabujito-problems} for \NBJ that the only way to circumvent such issues is by creating modified \VMs which enable specific interaction points.
There are other \PH-based research projects \cite{??} that took the same path and created a modified \VM.
We, believe that with an extended low-level \MOP the focus for research projects could shift from the \VM to the language-side.
The final extreme is to have a system that works like the described \Klein \VM where there is no longer a clear distinction of what is \VM-level and what is language-side.

\paragraph{Anticipated Debugging}
For \B we have more modest intermediate goals.
The major drawback for a seamless developer experience is the lack of a dedicate low-level debugging infrastructure.
At this point, \B developers have to rely on 3rd-party C-centric tools for debugging.
Hence, a developer has to decide upfront at which abstraction level the debugging should occur.
Either at high-level without the possibility to deal with low-level errors, or at low-level losing all the inspection capabilities.
Besides the shortcomings that either side of the decision will bring, already the fact that the debugging direction has to be anticipated is inappropriate.

We outlined in \secref{benzo-problems-debugging} already several ways to improve the current debugging situation for \B.
The most important focus is on reducing the cases where the programmer has to anticipate the debugging tool.
Since we have to deal with two very distinct abstraction levels we can not only rely on a pure language-side solution to provide different debuggers \cite{Towards a Moldable Debugger}.
The major problem is the serious implications of a low-level error.
Unlike user-level errors they are not well-defined or even contained.
It is astonishingly simple to corrupt the \VM memory while writing low-level code and thus breaking any contract with the \VM code.
However, it is more common to access protected memory due to a wrongly dereferenced pointer.
Hence, the \B should focus on this most common bug by following the solution outlined in \figref{benzo-debugger}.
%
\begin{figure}[h]
	\centering
	\includegraphics[scale=\imagescale]{benzo-debugger}
	\caption{\B Debugger Outline}
	\figlabel{benzo-debugger}
\end{figure}
%
\begin{enumerate}
	\item Standard \PH method activating a \B-enabled method through the \ttt{primitiveNativeCall} primitive.
	\item Native code causing a memory access violation (for example \ttt{SIGSEV}) which can not be handled by \PH directly.
	\item Low-level signal handler is activated by the operating system and tries to walk back the native stack up to the \ttt{primitiveNativeCall} activation.
	\item After successfully finding the \ttt{primitiveNativeCall} the signal handler sends a \B failure back to \PH.
\end{enumerate}

\paragraph{Missing Barrier-free Debugging}
After proposing a solution to improve \B's bug recovery behavior we immediately encounter a second problem.
How do we debug low-level code?
With the aforementioned solution we are able to recover from certain low-level errors and signal them properly at language-side.
In a \ST-like environment the debugger will pop up on the location causing the error and thus allowing a programmer to inspect stack and variables.
To provide the same facility for \B we have to plug into the existing low-level debugging utilities such as \ttt{ptrace} to enable stepping over native instructions.
The following \figref{benzo-crossover-debugger} outlines the basics of a debugger that crosses the high-level / low-level barrier.
%
\begin{figure}[h]
	\centering
	\includegraphics[scale=\imagescale]{benzo-crossover-debugger}
	\caption{\B Crossover Debugger Outline}
	\figlabel{benzo-crossover-debugger}
\end{figure}
%
\begin{enumerate}
	\item Point where a \B initiates a native call and the debugger switches from a high-level \PH stack to the low-level native stack.
To properly use low-level debugging tools we fork the complete \VM process.
	\item The low-level debugger in \PH switches the underlying debugging interface.
Instead of directly interacting with first-class \PH context we communicate to the the forked process with tools like \ttt{ptrace}.
	\item The forked process is updated according to the actions initiated from the \PH side.
\end{enumerate}

\noindent The outlined debugger will not work in certain cases where the native code directly interacts with the outer image.
The forked debugger process provides security from the main \PH image by isolating it.
However, for many \B applications such as the \FFI implementation this limitation would not apply.

% -----------------------------------------------------------------------------
\subsection{Virtual \CPU an Assembler \DSL}
% -----------------------------------------------------------------------------
\B uses \AsmJIT as assembler backend which is currently limited to x86 instruction set.
This choice is aligned with \PH's main development focus for the most common operating systems.
However, this choice of architecture already excludes mobile devices which currently focus on \ARM-based architectures.
To support this new architecture we have to extend the assembler backend in \AsmJIT.
While the implementation effort for a new \AsmJIT architecture is an implicit requirement the implications on \B-based applications are more severe.
For instance we already mentioned in \secref{ffi-problems-platform} how the \NB \FFI would suffer from code duplication.
Essentially each newly added \CPU architecture has ripple-effects up to the final \B-based applications.
Each \B application has to duplicate all native usage in and create internally separate generates for each platform.
We believe that this approach is not the right path as it forces \B users into code duplication.

A much better solution is to provide a more abstract and platform independent low-level intermediate format at \B-level.
Ideally we can push the platform specific code generation fully to the native backends in \B itself.
\B-based applications only have to focus on a single low-level instruction format reducing the development effort.


We also noticed that for actual testing the native instruction set is not optimal.
For instance the x86 instruction with all its modifier codes and variable width instructions makes it tedious to implement a proper simulator.
Writing bindings for an existing simulator such as \urlfootnote{\Bochs}{http://bochs.sourceforge.net/} is a better choice.
However, even with a proper simulator ready for x86 we can not provide a very fluent debugging process.
For instance, the way assembler instructions are written in \B require them to be fully generated before they can be interpreted.
We are used from \PH that any code snipped is executable, a property that we would like to bring to the low-level development as well.

\paragraph{\VCPU: A Low-level Intermediate Format}
To reduce the aforementioned platform dependency of \B we developed a intermediate low-level representation called \VCPU.
It is based on a three-address-code (\TAC) \cite{??} to simplify the adoption of optimizations such as static single assignment (\SSA) \cite{??}.
Additionally we chose to postpone register allocation to the final code generation phase.
By using a \TAC-based format and rewiring the internals we are even able to make the \VCPU code directly executable in \PH.

Before we go into the implementation details of \VCPU we show it is used.
\VCPU is based on \TAC instruction which take the following form:
%
\begin{stcode}{}
result := argument1 OP argument2
\end{stcode}
%
There are three operands involved, \ttt{result}, \ttt{argument1} and \ttt{argument2}, from which the name of this \TAC format originates.
Based on this assumption, each standard \VCPU instruction returns a temporary variable which can be used for further operations.
This makes the information-flow much more consistent.
For instance the x86 instructions which sometimes have a predefined result register and sometimes not.

The following code example outlines the basic usage of \VCPU:
%
\begin{stcode}[
	label={lst:benzo-problem-vcpu}, 
	caption={Basic \VCPU Example}
]{}
Benzo vcpu x86 generate: [ :cpu | | temp1 temp2 |
	temp1 := cpu memoryAt: 16r12345.
	temp2 := cpu uint: 2.
	cpu return: temp1 + temp1 ]
\end{stcode}
%
Which corresponds to the same functionality expressed in the following x86 instructions:
%
\begin{stcode}{}
Benzo x86 generate: [ :asm |
	asm mov: 16r12345 ptr to: asm EAX.
	asm add: asm EAX with: 2.
	asm return ]
\end{stcode}
%
For this basic example we see that the two formats do not differ very much.
Though, already on the example of the \ttt{return} instruction it becomes obvious that the \TAC-based solution is more explicit.
When using more complex control structures the difference is apparent:
\begin{stcode}{}
Benzo vcpu x86 generate: [ :cpu || a b c |
	a := cpu uint: 1.
	b := cpu uint: 2.
	c := cpu uint: 3.
	(a = b and: b = c) 
		ifTrue:  [ c value: 5  ] 
		ifFalse: [ c value: 10 ].
]
\end{stcode}
%
\VCPU benefits from using explicit instruction objects to add a \PH-like \DSL on top.
The previous example looks fairly similar in plain \PH code:
%
\begin{stcode}{}
| a b c |
a := 1.
b := 2.
c := 3.
(a = b and: b = c) 
	ifTrue:  [ c := 5  ] 
	ifFalse: [ c := 10 ].
\end{stcode}
%
The \DSL is transparently implemented by adding \PH methods on the corresponding \VCPU instructions.
Under the hood \VCPU will lower the \TAC instructions to low-level \ASM instructions for the \AsmJIT backend.


\paragraph{\VCPU Implementation}
So far we presented the external interface of the \VCPU format which works similar to the existing \B assembler format.
We will now shed lights on the internal implementation details of \VCPU which is divided in three classes of objects:
%
\begin{description}
	\item[\CPUs:] Source for values named \ttt{cpu} in the previous examples.
	The \CPU object will contain the list of instructions and for which backend it should generate the native code.
	
	\item[Instructions:] Encapsulates an instruction type, operands and result value according to the \TAC format.
	Additionally each instructions holds a backpointer to the \CPU it originated.
	For example \ttt{temp1 + temp1} yields a \VCPU instruction.
	
	\item[Low-level Objects:] A category of values or helper objects.
	For example \ttt{cpu uint: 1} will create low-level word that contains the value \ttt{1}.
\end{description}



\todo{\VCPU interpreter} \\
\todo{tracer backend for code generation} \\
\todo{Native Simluator for the specific backends} \\
\todo{Requires mapping from native instruction to the \VCPU instructions}

\paragraph{Instruction Objects}

%%\todo{Design overview/flow figure with backends} \\
\todo{inject high-level instructions} \\

\paragraph{\VCPU Optimizations}
\todo{Optimizations required for \B-based applications can be shared} \\

To get to the final native instructions the \VCPU infrastructure compiles the high-level instructions to the specific backend.
The current compiler is divided into the following passes:
%
\begin{itemize}[noitemsep]
\item Platform Specific Transformation
\item Register Allocation
\item Superfluous Assignment Remover
\item Platform Specific Assembler
\end{itemize}



\todo{Current State of the Implementation} \\
\todo{Support new Platforms} \\
\todo{Indirect support for simluation and thus better debugging}


% =============================================================================
\section{\VM-level Improvements}
\seclabel{future-vm}
% =============================================================================
\todo{Introduction: Lanugage-side is not enough} \\
\todo{Need to get a obstacle-free VM} \\
\todo{List of requirements for a new VM Infrastructure} \\ 
\todo{Small comparison against the current solution we have with COG} \\
\todo{Follow the \Klein approach}


% -----------------------------------------------------------------------------
\subsection{VM-level Reification}
% -----------------------------------------------------------------------------
\todo{Resulting from the first law of Inspectors, all VM-level objects are reified} \\
\todo{List of typical objects that don't have a reification in COG} \\
\todo{List advantages}\\
\todo{make concepts explicit and first-class} \\
\todo{limit the use of raw memory access and string-based programming} \\

% -----------------------------------------------------------------------------
\subsection{Runtime Reification / Dual Objects}
% -----------------------------------------------------------------------------
\todo{Reuse the same objects for the bootstrap and at runtime inspectors/mirrors} \\
\todo{goes further than the sheer compile-time reification} \\
\todo{accessible from language-side => leads to the following MOP}

% -----------------------------------------------------------------------------
\subsection{Mate Object Model and Runtime MOP}
% -----------------------------------------------------------------------------
\todo{consequence of the runtime reification of the VM introspection => intercession}\\
\todo{Rough Overview of all the Objects currently present in Mate (UMLish)}

% -----------------------------------------------------------------------------
\subsection{Be Native}
% -----------------------------------------------------------------------------
\todo{out of the intercession capabilities follows that we need native support at runtime (see \B)}\\
\todo{that means we need to have decent / better infrasrtucture for native code}\\
\todo{need to be able to achieve what \NBJ didn't manage: compile native methods and hand them over to the \VM}\\
\todo{step towards our implementation in \Mate}


% =============================================================================
\section{\Mate a Reflective \VM Prototype}
\seclabel{mate}
% =============================================================================

\begin{figure*}[h]
	\begin{adjustwidth}{-10.0in}{-10.0in}
		\centering
		\includegraphics[width=1.02\textwidth]{mate-logo}
	\end{adjustwidth}
\end{figure*}

\todo{introduction: protoype based on the conclusions presented in the previous sections}\\
\todo{for reasearch mainly but possible long term solution to our \VM problems}

% -----------------------------------------------------------------------------
\subsection{Mate Compiler Outline}
\seclabel{future-mate-compiler}
% -----------------------------------------------------------------------------
\todo{Small Intro: Reuse the bootstrap infrastrucutre at runtime (FFI, JIT...)}

\begin{figure}[H]
\centering
	\includegraphics[width=\textwidth]{mate-compilation-toolchain}
\end{figure}

% -----------------------------------------------------------------------------
\subsection{Mate Bootstrap Outline}
\todo{Small Intro: Why Bootstrap and how to use the reified objects}\\
\todo{Compare to Pinocchio (manual approach)}\\
\todo{Work in Progress: Envision the trace-based Bootstrap}


% -----------------------------------------------------------------------------
\subsection{Mate Towards Complete Reflection}
\todo{list possible paths between the 4 quadrants of reflection}\\
\todo{usecase: dynamic gc change}\\
\todo{usecase: dynamic object format influence}\\
\todo{usecase: optimize partial behavior reflection (immutability, proxies)}\\

% =============================================================================
\section{SISTA: Language-side Adaptive Recompilation}
% =============================================================================

\todo{do we put this in a separate section?}\\
\todo{related to \NBJ, but more real-world approach}

% =============================================================================
\section{Reflective Future}
% =============================================================================
% NEW concepts
\todo{Check with GUIDO} \\
\todo{List 3 to 4 different Examples entering the 4th quadrant:}

% -----------------------------------------------------------------------------
\subsection{Accessible VM Components}
% -----------------------------------------------------------------------------
\todo{Access GC Statistics} \\
\todo{Access JIT Statistics for Type Annotations / Tooling}

% -----------------------------------------------------------------------------
\subsection{Interchangeable VM Components}
% -----------------------------------------------------------------------------
\todo{Change GC strategy} \\
\todo{Change JIT Strategy}

% -----------------------------------------------------------------------------
\subsection{Interchangeable Language Semantics}
% -----------------------------------------------------------------------------
\todo{Up to which extent can this be supported?} \\
\todo{Related to VM MOP: How much should be changeable? When?}


% -----------------------------------------------------------------------------
\subsection{Efficient Reflection}
% -----------------------------------------------------------------------------
\todo{Reflectivity at VM-level} \\
\todo{Flatten but don't freeze Reflection/Abstraction}


% =============================================================================
\section{Summary}
% =============================================================================

\todo{a lot of work on the engineering level to get a \VM with reflective properties}\\
\todo{- limited resources focused on maintaining the current infrastructure} \\
\todo{for research we have already sufficient tools at hand to experiment} \\
\todo{- outline some stuff for guido} \\
\todo{possiblity to split up off tools to be used by \PH} \\
\todo{- VCPU IR} \\
\todo{- improved FFI}


% =============================================================================
\input{chapter-footer.tex}